{"version":3,"sources":["../src/lib/editor/withSlate.ts","../src/internal/mergePlugins.ts","../src/lib/utils/misc/isFunction.ts","../src/lib/plugin/createSlatePlugin.ts","../src/lib/utils/applyDeepToNodes.ts","../src/lib/utils/getInjectedPlugins.ts","../src/lib/utils/getKeysByTypes.ts","../src/lib/utils/hotkeys.ts","../src/lib/utils/mergeDeepToNodes.ts","../src/lib/utils/normalizeDescendantsToDocumentFragment.ts","../src/lib/plugin/getEditorPlugin.ts","../src/lib/plugins/AstPlugin.ts","../src/lib/plugins/DOMPlugin.ts","../src/lib/plugins/HistoryPlugin.ts","../src/lib/plugins/InlineVoidPlugin.ts","../src/lib/plugins/ParserPlugin.ts","../src/lib/plugins/debug/DebugPlugin.ts","../src/lib/plugins/editor-protocol/SlateNextPlugin.ts","../src/lib/transforms/resetEditorChildren.ts","../src/lib/transforms/resetEditor.ts","../src/lib/transforms/toggleBlock.ts","../src/lib/plugins/paragraph/BaseParagraphPlugin.ts","../src/lib/plugins/html/HtmlPlugin.ts","../src/lib/plugins/html/constants.ts","../src/lib/plugins/html/utils/isHtmlElement.ts","../src/lib/plugins/html/utils/traverseHtmlNode.ts","../src/lib/plugins/html/utils/traverseHtmlElements.ts","../src/lib/plugins/html/utils/cleanHtmlBrElements.ts","../src/lib/plugins/html/utils/cleanHtmlCrLf.ts","../src/lib/plugins/html/utils/cleanHtmlEmptyElements.ts","../src/lib/plugins/html/utils/replaceTagName.ts","../src/lib/plugins/html/utils/cleanHtmlFontElements.ts","../src/lib/plugins/html/utils/isHtmlFragmentHref.ts","../src/lib/plugins/html/utils/unwrapHtmlElement.ts","../src/lib/plugins/html/utils/cleanHtmlLinkElements.ts","../src/lib/plugins/html/utils/isHtmlText.ts","../src/lib/plugins/html/utils/traverseHtmlTexts.ts","../src/lib/plugins/html/utils/cleanHtmlTextNodes.ts","../src/lib/plugins/html/utils/inlineTagNames.ts","../src/lib/plugins/html/utils/isHtmlInlineElement.ts","../src/lib/plugins/html/utils/isHtmlBlockElement.ts","../src/lib/plugins/html/utils/isHtmlTable.ts","../src/lib/plugins/html/utils/copyBlockMarksToSpanChild.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseString.ts","../src/lib/plugins/html/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts","../src/lib/plugins/html/utils/collapse-white-space/stateTransforms.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceText.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceNode.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceChildren.ts","../src/lib/plugins/html/utils/collapse-white-space/inferWhiteSpaceRule.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceElement.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpace.ts","../src/lib/plugins/html/utils/htmlBodyToFragment.ts","../src/lib/plugins/html/utils/deserializeHtmlNodeChildren.ts","../src/lib/plugins/html/utils/htmlBrToNewLine.ts","../src/lib/plugins/html/utils/htmlElementToElement.ts","../src/lib/plugins/html/utils/pluginDeserializeHtml.ts","../src/lib/plugins/html/utils/pipeDeserializeHtmlElement.ts","../src/lib/plugins/html/utils/htmlElementToLeaf.ts","../src/lib/plugins/html/utils/pipeDeserializeHtmlLeaf.ts","../src/lib/plugins/html/utils/htmlTextNodeToString.ts","../src/lib/plugins/html/utils/deserializeHtmlNode.ts","../src/lib/plugins/html/utils/deserializeHtmlElement.ts","../src/lib/plugins/html/utils/htmlStringToDOMNode.ts","../src/lib/plugins/html/utils/deserializeHtml.ts","../src/lib/plugins/html/utils/findHtmlElement.ts","../src/lib/plugins/html/utils/getHtmlComments.ts","../src/lib/plugins/html/utils/isHtmlComment.ts","../src/lib/plugins/html/utils/isOlSymbol.ts","../src/lib/plugins/html/utils/parseHtmlDocument.ts","../src/lib/plugins/html/utils/parseHtmlElement.ts","../src/lib/plugins/html/utils/postCleanHtml.ts","../src/lib/plugins/html/utils/removeHtmlSurroundings.ts","../src/lib/plugins/html/utils/preCleanHtml.ts","../src/lib/plugins/html/utils/traverseHtmlComments.ts","../src/lib/plugins/html/utils/removeHtmlNodesBetweenComments.ts","../src/lib/plugins/length/LengthPlugin.ts","../src/lib/plugins/getCorePlugins.ts","../src/lib/utils/overridePluginsByKey.ts","../src/lib/utils/pluginInjectNodeProps.ts","../src/lib/utils/pipeInjectNodeProps.tsx","../src/lib/utils/pipeInsertDataQuery.ts","../src/lib/utils/pipeInsertFragment.ts","../src/lib/utils/pipeNormalizeInitialValue.ts","../src/lib/utils/pipeTransformData.ts","../src/lib/utils/pipeTransformFragment.ts","../src/lib/utils/resolvePlugin.ts","../src/lib/utils/resolveCreatePluginTest.ts","../src/lib/utils/resolvePlugins.ts","../src/lib/utils/misc/callOrReturn.ts","../src/lib/utils/misc/getSlateClass.ts","../src/lib/utils/misc/mergeDeep.ts","../src/lib/plugin/getSlatePlugin.ts","../src/lib/libs/nanoid.ts","../src/lib/libs/zustand.ts"],"sourcesContent":["import {\n  type TEditor,\n  type TSelection,\n  type Value,\n  createTEditor,\n  getEndPoint,\n  getStartPoint,\n  normalizeEditor,\n  select,\n} from '@udecode/slate';\n\nimport type { AnyPluginConfig } from '../plugin/BasePlugin';\nimport type { AnySlatePlugin } from '../plugin/SlatePlugin';\nimport type { InferPlugins, SlateEditor, TSlateEditor } from './SlateEditor';\n\nimport { createSlatePlugin } from '../plugin/createSlatePlugin';\nimport { getPluginType, getSlatePlugin } from '../plugin/getSlatePlugin';\nimport { type CorePlugin, getCorePlugins } from '../plugins/getCorePlugins';\nimport { pipeNormalizeInitialValue } from '../utils/pipeNormalizeInitialValue';\nimport { resolvePlugins } from '../utils/resolvePlugins';\n\nexport type BaseWithSlateOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = {\n  id?: any;\n\n  /**\n   * Select the editor after initialization.\n   *\n   * @default false\n   *\n   * - `true` | 'end': Select the end of the editor\n   * - `false`: Do not select anything\n   * - `'start'`: Select the start of the editor\n   */\n  autoSelect?: boolean | 'end' | 'start';\n\n  /** Specifies the maximum number of characters allowed in the editor. */\n  maxLength?: number;\n\n  plugins?: P[];\n\n  selection?: TSelection;\n\n  /**\n   * When `true`, it will normalize the initial `value` passed to the `editor`.\n   * This is useful when adding normalization rules on already existing\n   * content.\n   *\n   * @default false\n   */\n  shouldNormalizeEditor?: boolean;\n\n  value?: V | string;\n};\n\nexport type WithSlateOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = BaseWithSlateOptions<V, P> &\n  Pick<\n    Partial<AnySlatePlugin>,\n    | 'api'\n    | 'decorate'\n    | 'extendEditor'\n    | 'inject'\n    | 'normalizeInitialValue'\n    | 'options'\n    | 'override'\n    | 'transforms'\n  > & {\n    /** Function to configure the root plugin */\n    rootPlugin?: (plugin: AnySlatePlugin) => AnySlatePlugin;\n  };\n\n/**\n * Applies Plate enhancements to an editor instance (non-React version).\n *\n * @remarks\n *   This function supports server-side usage as it doesn't include the\n *   ReactPlugin.\n * @see {@link createSlateEditor} for a higher-level non-React editor creation function.\n * @see {@link createPlateEditor} for a higher-level React editor creation function.\n * @see {@link usePlateEditor} for a React memoized version.\n * @see {@link withPlate} for the React-specific enhancement function.\n */\nexport const withSlate = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>(\n  e: TEditor,\n  {\n    id,\n    autoSelect,\n    maxLength,\n    plugins = [],\n    rootPlugin,\n    selection,\n    shouldNormalizeEditor,\n    value,\n    ...pluginConfig\n  }: WithSlateOptions<V, P> = {}\n): TSlateEditor<V, InferPlugins<P[]>> => {\n  const editor = e as SlateEditor;\n\n  // Override incremental id generated by slate\n  editor.id = id ?? editor.id;\n  editor.key = editor.key ?? Math.random();\n  editor.isFallback = false;\n\n  editor.getApi = () => editor.api as any;\n  editor.getTransforms = () => editor.transforms as any;\n  editor.getPlugin = (plugin) => getSlatePlugin(editor, plugin) as any;\n  editor.getType = (plugin) => getPluginType(editor, plugin);\n  editor.getInjectProps = (plugin) => {\n    return (\n      editor.getPlugin<AnySlatePlugin>(plugin).inject?.nodeProps ?? ({} as any)\n    );\n  };\n  editor.getOptionsStore = (plugin) => {\n    return editor.getPlugin(plugin).optionsStore;\n  };\n  editor.getOptions = (plugin) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return editor.getPlugin(plugin).options;\n\n    return editor.getOptionsStore(plugin).get.state();\n  };\n  editor.getOption = (plugin, key, ...args) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return editor.getPlugin(plugin).options[key];\n\n    const getter = (store.get as any)[key];\n\n    if (getter) {\n      return getter(...args);\n    }\n\n    editor.api.debug.error(\n      `editor.getOption: ${key as string} option is not defined in plugin ${plugin.key}.`,\n      'OPTION_UNDEFINED'\n    );\n  };\n  editor.setOption = (plugin: any, key: any, value: any) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return;\n\n    const setter = (store.set as any)[key];\n\n    if (setter) {\n      setter(value);\n    } else {\n      editor.api.debug.error(\n        `editor.setOption: ${key} option is not defined in plugin ${plugin.key}.`,\n        'OPTION_UNDEFINED'\n      );\n    }\n  };\n  editor.setOptions = (plugin: any, options: any) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return;\n    if (typeof options === 'object') {\n      (store.set as any).mergeState(options);\n    } else if (typeof options === 'function') {\n      (store.set as any).state(options);\n    }\n  };\n\n  const corePlugins = getCorePlugins({\n    maxLength,\n    plugins,\n  });\n\n  let rootPluginInstance = createSlatePlugin({\n    key: 'root',\n    priority: 10_000,\n    ...pluginConfig,\n    plugins: [...corePlugins, ...plugins],\n  });\n\n  // Apply rootPlugin configuration if provided\n  if (rootPlugin) {\n    rootPluginInstance = rootPlugin(rootPluginInstance) as any;\n  }\n\n  resolvePlugins(editor, [rootPluginInstance]);\n\n  if (typeof value === 'string') {\n    editor.children = editor.api.html.deserialize({ element: value }) as Value;\n  } else if (value) {\n    editor.children = value;\n  }\n  if (editor.children?.length === 0) {\n    editor.children = editor.api.create.value();\n  }\n  if (selection) {\n    editor.selection = selection;\n  } else if (autoSelect) {\n    const edge = autoSelect === 'start' ? 'start' : 'end';\n    const target =\n      edge === 'start' ? getStartPoint(editor, []) : getEndPoint(editor, []);\n    select(editor, target);\n  }\n  if (value) {\n    pipeNormalizeInitialValue(editor);\n  }\n  if (shouldNormalizeEditor) {\n    normalizeEditor(editor, { force: true });\n  }\n\n  return editor as any;\n};\n\nexport type CreateSlateEditorOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = WithSlateOptions<V, P> & {\n  /**\n   * Initial editor to be extended with `withPlate`.\n   *\n   * @default createEditor()\n   */\n  editor?: TEditor;\n};\n\n/**\n * Creates a Slate editor without React-specific enhancements.\n *\n * @see {@link createPlateEditor} for a React-specific version of editor creation.\n * @see {@link usePlateEditor} for a memoized React version.\n * @see {@link withSlate} for the underlying function that applies Slate enhancements to an editor.\n */\nexport const createSlateEditor = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>({\n  editor = createTEditor(),\n  ...options\n}: CreateSlateEditorOptions<V, P> = {}) => {\n  return withSlate<V, P>(editor, options);\n};\n","import mergeWith from 'lodash/mergeWith.js';\n\nimport type { SlatePlugin } from '../lib';\n\nexport function mergePlugins<T>(basePlugin: T, ...sourcePlugins: any[]): T {\n  return mergeWith(\n    {},\n    basePlugin,\n    ...sourcePlugins,\n    (objValue: unknown, srcValue: unknown, key: keyof SlatePlugin) => {\n      // Overwrite array (including plugins) without cloning\n      if (Array.isArray(srcValue)) {\n        return srcValue;\n      }\n      // Shallow merge options\n      if (key === 'options') {\n        return { ...(objValue as any), ...(srcValue as any) };\n      }\n    }\n  );\n}\n","// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport function isFunction(value: any): value is Function {\n  return typeof value === 'function';\n}\n","import type { Modify } from '@udecode/utils';\n\nimport type { SlateEditor } from '../editor/SlateEditor';\nimport type { AnyPluginConfig, PluginConfig } from './BasePlugin';\nimport type {\n  SlatePlugin,\n  SlatePluginMethods,\n  SlatePlugins,\n} from './SlatePlugin';\n\nimport { mergePlugins } from '../../internal/mergePlugins';\nimport { isFunction } from '../utils/misc/isFunction';\n\ntype SlatePluginConfig<K extends string = any, O = {}, A = {}, T = {}> = Omit<\n  Partial<\n    Modify<\n      SlatePlugin<PluginConfig<K, O, A, T>>,\n      {\n        node?: Partial<SlatePlugin<PluginConfig<K, O, A, T>>['node']>;\n      }\n    >\n  >,\n  keyof SlatePluginMethods | 'optionsStore'\n>;\n\ntype TSlatePluginConfig<C extends AnyPluginConfig = PluginConfig> = Omit<\n  Partial<\n    Modify<\n      SlatePlugin<C>,\n      {\n        node?: Partial<SlatePlugin<C>['node']>;\n      }\n    >\n  >,\n  keyof SlatePluginMethods | 'optionsStore'\n>;\n\n/**\n * Creates a new Plate plugin with the given configuration.\n *\n * @remarks\n *   - The plugin's key is required and specified by the K generic.\n *   - The `__extensions` array stores functions to be applied when `resolvePlugin`\n *       is called with an editor.\n *   - The `extend` method adds new extensions to be applied later.\n *   - The `extendPlugin` method extends an existing plugin (including nested\n *       plugins) or adds a new one if not found.\n *\n * @example\n *   const myPlugin = createSlatePlugin<\n *     'myPlugin',\n *     MyOptions,\n *     MyApi,\n *     MyTransforms\n *   >({\n *     key: 'myPlugin',\n *     options: { someOption: true },\n *     transforms: { someTransform: () => {} },\n *   });\n *\n *   const extendedPlugin = myPlugin.extend({\n *     options: { anotherOption: false },\n *   });\n *\n *   const pluginWithNestedExtension = extendedPlugin.extendPlugin(\n *     nestedPlugin,\n *     {\n *       options: { nestedOption: true },\n *     }\n *   );\n *\n * @template K - The literal type of the plugin key.\n * @template O - The type of the plugin options.\n * @template A - The type of the plugin utilities.\n * @template T - The type of the plugin transforms.\n * @template S - The type of the plugin storage.\n * @param {Partial<SlatePlugin<K, O, A, T>>} config - The configuration object\n *   for the plugin.\n * @returns {SlatePlugin<K, O, A, T>} A new Plate plugin instance with the\n *   following properties and methods:\n *\n *   - All properties from the input config, merged with default values.\n *   - `configure`: A method to create a new plugin instance with updated options.\n *   - `extend`: A method to create a new plugin instance with additional\n *       configuration.\n *   - `extendPlugin`: A method to extend an existing plugin (including nested\n *       plugins) or add a new one if not found.\n */\nexport function createSlatePlugin<\n  K extends string = any,\n  O = {},\n  A = {},\n  T = {},\n>(\n  config:\n    | ((editor: SlateEditor) => SlatePluginConfig<K, O, A, T>)\n    | SlatePluginConfig<K, O, A, T> = {}\n): SlatePlugin<PluginConfig<K, O, A, T>> {\n  let baseConfig: Partial<SlatePlugin<PluginConfig<K, O, A, T>>>;\n  let initialExtension: any;\n\n  if (isFunction(config)) {\n    baseConfig = { key: '' as K };\n    initialExtension = (editor: any) => config(editor);\n  } else {\n    baseConfig = config as any;\n  }\n\n  const key = baseConfig.key ?? '';\n\n  const plugin = mergePlugins(\n    {\n      key,\n      __apiExtensions: [],\n      __configuration: null,\n      __extensions: initialExtension ? [initialExtension] : [],\n      __optionExtensions: [],\n      api: {},\n      dependencies: [],\n      editor: {},\n      inject: {},\n      node: { type: key },\n      options: {},\n      override: {},\n      parser: {},\n      parsers: {},\n      plugins: [],\n      priority: 100,\n      render: {},\n      shortcuts: {},\n      transforms: {},\n      handlers: {},\n    },\n    config\n  ) as unknown as SlatePlugin<PluginConfig<K, O, A, T>>;\n\n  plugin.configure = (config) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__configuration = (ctx) =>\n      isFunction(config) ? config(ctx as any) : config;\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.configurePlugin = (p, config) => {\n    const newPlugin = { ...plugin };\n\n    const configureNestedPlugin = (\n      plugins: SlatePlugins\n    ): { found: boolean; plugins: SlatePlugins } => {\n      let found = false;\n\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n\n          return createSlatePlugin({\n            ...nestedPlugin,\n            __configuration: (ctx: any) =>\n              isFunction(config) ? config(ctx) : config,\n          } as any);\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result = configureNestedPlugin(nestedPlugin.plugins);\n\n          if (result.found) {\n            found = true;\n\n            return {\n              ...nestedPlugin,\n              plugins: result.plugins,\n            };\n          }\n        }\n\n        return nestedPlugin;\n      });\n\n      return { found, plugins: updatedPlugins };\n    };\n\n    const result = configureNestedPlugin(newPlugin.plugins as any);\n    newPlugin.plugins = result.plugins as any;\n\n    // We're not adding a new plugin if not found\n\n    return createSlatePlugin(newPlugin);\n  };\n\n  plugin.extendEditorApi = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: false },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendOptions = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__optionExtensions = [\n      ...(newPlugin.__optionExtensions as any),\n      extension,\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendApi = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendEditorTransforms = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: false, isTransform: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendTransforms = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: true, isTransform: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extend = (extendConfig) => {\n    let newPlugin = { ...plugin };\n\n    if (isFunction(extendConfig)) {\n      newPlugin.__extensions = [\n        ...(newPlugin.__extensions as any),\n        extendConfig,\n      ];\n    } else {\n      newPlugin = mergePlugins(newPlugin, extendConfig as any);\n    }\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.clone = () => mergePlugins(plugin);\n\n  plugin.extendPlugin = (p, extendConfig) => {\n    const newPlugin = { ...plugin };\n\n    const extendNestedPlugin = (\n      plugins: SlatePlugins\n    ): { found: boolean; plugins: SlatePlugins } => {\n      let found = false;\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n\n          return createSlatePlugin({\n            ...nestedPlugin,\n            __extensions: [\n              ...(nestedPlugin.__extensions as any),\n              (ctx: any) =>\n                isFunction(extendConfig) ? extendConfig(ctx) : extendConfig,\n            ],\n          } as any);\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result = extendNestedPlugin(nestedPlugin.plugins);\n\n          if (result.found) {\n            found = true;\n\n            return {\n              ...nestedPlugin,\n              plugins: result.plugins,\n            };\n          }\n        }\n\n        return nestedPlugin;\n      });\n\n      return { found, plugins: updatedPlugins };\n    };\n\n    const result = extendNestedPlugin(newPlugin.plugins as any);\n    newPlugin.plugins = result.plugins as any;\n\n    // If the plugin wasn't found at any level, add it at the top level\n    if (!result.found) {\n      newPlugin.plugins.push(\n        createSlatePlugin({\n          key: p.key,\n          __extensions: [\n            (ctx: any) =>\n              isFunction(extendConfig)\n                ? extendConfig(ctx as any)\n                : (extendConfig as any),\n          ],\n        } as any)\n      );\n    }\n\n    return createSlatePlugin(newPlugin);\n  };\n\n  return plugin;\n}\n\n/**\n * Explicitly typed version of `createSlatePlugin`.\n *\n * @remarks\n *   While `createSlatePlugin` uses type inference, this function requires an\n *   explicit type parameter. Use this when you need precise control over the\n *   plugin's type structure or when type inference doesn't provide the desired\n *   result.\n */\nexport function createTSlatePlugin<C extends AnyPluginConfig = PluginConfig>(\n  config:\n    | ((editor: SlateEditor) => TSlatePluginConfig<C>)\n    | TSlatePluginConfig<C> = {}\n): SlatePlugin<C> {\n  return createSlatePlugin(config as any) as any;\n}\n","import type { Path } from 'slate';\n\nimport {\n  type NodeOf,\n  type QueryNodeOptions,\n  type TNode,\n  type TNodeEntry,\n  isAncestor,\n  queryNode,\n} from '@udecode/slate';\n\nexport interface ApplyDeepToNodesOptions<N extends TNode> {\n  // Function to call on each node following the query.\n  apply: (\n    node: NodeOf<N>,\n    source: (() => Record<string, any>) | Record<string, any>\n  ) => void;\n  // The destination node object.\n  node: N;\n  // The source object. Can be a factory.\n  source: (() => Record<string, any>) | Record<string, any>;\n  path?: Path;\n  // Query to filter the nodes.\n  query?: QueryNodeOptions;\n}\n\n/** Recursively apply an operation to children nodes with a query. */\nexport const applyDeepToNodes = <N extends TNode>({\n  apply,\n  node,\n  path = [],\n  query,\n  source,\n}: ApplyDeepToNodesOptions<N>) => {\n  const entry: TNodeEntry<N> = [node, path];\n\n  if (queryNode<N>(entry, query)) {\n    if (source instanceof Function) {\n      apply(node, source());\n    } else {\n      apply(node, source);\n    }\n  }\n  if (!isAncestor(node)) return;\n\n  node.children.forEach((child, index) => {\n    applyDeepToNodes({\n      apply,\n      node: child as any,\n      path: path.concat([index]),\n      query,\n      source,\n    });\n  });\n};\n","import type { SlateEditor } from '../editor';\nimport type { AnyEditorPlugin, SlatePlugins } from '../plugin/SlatePlugin';\n\n/**\n * Get all plugins having a defined `inject.plugins[plugin.key]`. It includes\n * `plugin` itself.\n */\nexport const getInjectedPlugins = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin\n): Partial<AnyEditorPlugin>[] => {\n  const injectedPlugins: SlatePlugins = [];\n\n  [...editor.pluginList].reverse().forEach((p) => {\n    const injectedPlugin = p.inject.plugins?.[plugin.key];\n\n    if (injectedPlugin) injectedPlugins.push(injectedPlugin as any);\n  });\n\n  return [plugin, ...injectedPlugins];\n};\n","import type { SlateEditor } from '../editor';\n\n/** Get plugin keys by types */\nexport const getKeysByTypes = (\n  editor: SlateEditor,\n  types: string[]\n): string[] => {\n  return Object.values(editor.plugins)\n    .filter((plugin) => types.includes(plugin.node.type))\n    .map((plugin) => plugin.key);\n};\n\n/** Get plugin key by type */\nexport const getKeyByType = (editor: SlateEditor, type: string): string => {\n  const plugin = Object.values(editor.plugins).find(\n    (plugin) => plugin.node.type === type\n  );\n\n  return plugin?.key ?? type;\n};\n","import { IS_APPLE } from '@udecode/utils';\nimport { type KeyboardEventLike, isKeyHotkey } from 'is-hotkey';\n\nexport { isHotkey } from 'is-hotkey';\n\n/** Hotkey mappings for each platform. */\nconst HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  insertSoftBreak: 'shift+enter',\n  italic: 'mod+i',\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  splitBlock: 'enter',\n  tab: 'tab',\n  undo: 'mod+z',\n  untab: 'shift+tab',\n};\n\nconst APPLE_HOTKEYS = {\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n};\n\nconst WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n};\n\n/** Create a platform-aware hotkey checker. */\n\nexport const createHotkey = (key: string) => {\n  const generic = (HOTKEYS as any)[key];\n  const apple = (APPLE_HOTKEYS as any)[key];\n  const windows = (WINDOWS_HOTKEYS as any)[key];\n  const isGeneric = generic && isKeyHotkey(generic);\n  const isApple = apple && isKeyHotkey(apple);\n  const isWindows = windows && isKeyHotkey(windows);\n\n  return (event: KeyboardEventLike) => {\n    if (isGeneric?.(event)) return true;\n    if (IS_APPLE && isApple?.(event)) return true;\n    if (!IS_APPLE && isWindows?.(event)) return true;\n\n    return false;\n  };\n};\n\nexport const Hotkeys = {\n  isBold: createHotkey('bold'),\n  isCompose: createHotkey('compose'),\n  isDeleteBackward: createHotkey('deleteBackward'),\n  isDeleteForward: createHotkey('deleteForward'),\n  isDeleteLineBackward: createHotkey('deleteLineBackward'),\n  isDeleteLineForward: createHotkey('deleteLineForward'),\n  isDeleteWordBackward: createHotkey('deleteWordBackward'),\n  isDeleteWordForward: createHotkey('deleteWordForward'),\n  isExtendBackward: createHotkey('extendBackward'),\n  isExtendForward: createHotkey('extendForward'),\n  isExtendLineBackward: createHotkey('extendLineBackward'),\n  isExtendLineForward: createHotkey('extendLineForward'),\n  isItalic: createHotkey('italic'),\n  isMoveBackward: createHotkey('moveBackward'),\n  isMoveForward: createHotkey('moveForward'),\n  isMoveLineBackward: createHotkey('moveLineBackward'),\n  isMoveLineForward: createHotkey('moveLineForward'),\n  isMoveWordBackward: createHotkey('moveWordBackward'),\n  isMoveWordForward: createHotkey('moveWordForward'),\n  isRedo: createHotkey('redo'),\n  isSoftBreak: createHotkey('insertSoftBreak'),\n  isSplitBlock: createHotkey('splitBlock'),\n  isTransposeCharacter: createHotkey('transposeCharacter'),\n  isUndo: createHotkey('undo'),\n};\n","import type { TNode } from '@udecode/slate';\n\nimport merge from 'lodash/merge.js';\n\nimport {\n  type ApplyDeepToNodesOptions,\n  applyDeepToNodes,\n} from './applyDeepToNodes';\n\n/** Recursively merge a source object to children nodes with a query. */\nexport const mergeDeepToNodes = <N extends TNode>(\n  options: Omit<ApplyDeepToNodesOptions<N>, 'apply'>\n) => {\n  applyDeepToNodes({ ...options, apply: merge });\n};\n","import {\n  type TDescendant,\n  type TEditor,\n  isElement,\n  isText,\n} from '@udecode/slate';\n\nimport type { SlateEditor } from '../editor';\n\nimport { BaseParagraphPlugin } from '../plugins';\n\nconst isInlineNode =\n  (editor: Pick<TEditor, 'isInline'>) => (node: TDescendant) =>\n    isText(node) || (isElement(node) && editor.isInline(node));\n\nconst makeBlockLazy = (type: string) => (): TDescendant => ({\n  children: [],\n  type,\n});\n\nconst hasDifferentChildNodes = (\n  descendants: TDescendant[],\n  isInline: (node: TDescendant) => boolean\n): boolean => {\n  return descendants.some((descendant, index, arr) => {\n    const prevDescendant = arr[index - 1];\n\n    if (index !== 0) {\n      return isInline(descendant) !== isInline(prevDescendant);\n    }\n\n    return false;\n  });\n};\n\n/**\n * Handles 3rd constraint: \"Block nodes can only contain other blocks, or inline\n * and text nodes.\"\n */\nconst normalizeDifferentNodeTypes = (\n  descendants: TDescendant[],\n  isInline: (node: TDescendant) => boolean,\n  makeDefaultBlock: () => TDescendant\n): TDescendant[] => {\n  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);\n\n  const { fragment } = descendants.reduce(\n    (memo, node) => {\n      if (hasDifferentNodes && isInline(node)) {\n        let block = memo.precedingBlock;\n\n        if (!block) {\n          block = makeDefaultBlock();\n          memo.precedingBlock = block;\n          memo.fragment.push(block);\n        }\n\n        (block.children as TDescendant[]).push(node);\n      } else {\n        memo.fragment.push(node);\n        memo.precedingBlock = null;\n      }\n\n      return memo;\n    },\n    {\n      fragment: [] as TDescendant[],\n      precedingBlock: null as TDescendant | null,\n    }\n  );\n\n  return fragment;\n};\n\n/**\n * Handles 1st constraint: \"All Element nodes must contain at least one Text\n * descendant.\"\n */\nconst normalizeEmptyChildren = (descendants: TDescendant[]): TDescendant[] => {\n  if (descendants.length === 0) {\n    return [{ text: '' } as TDescendant];\n  }\n\n  return descendants;\n};\n\nconst normalize = (\n  descendants: TDescendant[],\n  isInline: (node: TDescendant) => boolean,\n  makeDefaultBlock: () => TDescendant\n): TDescendant[] => {\n  descendants = normalizeEmptyChildren(descendants);\n  descendants = normalizeDifferentNodeTypes(\n    descendants,\n    isInline,\n    makeDefaultBlock\n  );\n\n  descendants = descendants.map((node) => {\n    if (isElement(node)) {\n      return {\n        ...node,\n        children: normalize(\n          node.children as TDescendant[],\n          isInline,\n          makeDefaultBlock\n        ),\n      };\n    }\n\n    return node;\n  });\n\n  return descendants;\n};\n\n/** Normalize the descendants to a valid document fragment. */\nexport const normalizeDescendantsToDocumentFragment = (\n  editor: SlateEditor,\n  { descendants }: { descendants: TDescendant[] }\n): TDescendant[] => {\n  const isInline = isInlineNode(editor);\n  const defaultType = editor.getType(BaseParagraphPlugin);\n  const makeDefaultBlock = makeBlockLazy(defaultType);\n\n  return normalize(descendants, isInline, makeDefaultBlock as any);\n};\n","import type { SlateEditor } from '../editor';\nimport type { AnyPluginConfig, WithRequiredKey } from './BasePlugin';\nimport type {\n  InferConfig,\n  SlatePlugin,\n  SlatePluginContext,\n} from './SlatePlugin';\n\nexport function getEditorPlugin<\n  P extends AnyPluginConfig | SlatePlugin<AnyPluginConfig>,\n>(\n  editor: SlateEditor,\n  p: WithRequiredKey<P>\n): SlatePluginContext<InferConfig<P> extends never ? P : InferConfig<P>> {\n  const plugin = editor.getPlugin(p) as any;\n\n  return {\n    api: editor.api,\n    editor,\n    getOption: (key: any, ...args: any) =>\n      editor.getOption(plugin, key, ...args),\n    getOptions: () => editor.getOptions(plugin),\n    plugin: plugin as any,\n    setOption: ((keyOrOptions: any, value: any) =>\n      editor.setOption(plugin, keyOrOptions, value)) as any,\n    setOptions: ((options: any) => editor.setOptions(plugin, options)) as any,\n    tf: editor.transforms,\n    type: plugin.node.type,\n  };\n}\n","import { createSlatePlugin } from '../plugin';\n\n/**\n * Enables support for deserializing inserted content from Slate Ast format to\n * Slate format while apply a small bug fix.\n */\nexport const AstPlugin = createSlatePlugin({\n  key: 'ast',\n  parser: {\n    deserialize: ({ data }) => {\n      const decoded = decodeURIComponent(window.atob(data));\n      let parsed;\n\n      try {\n        parsed = JSON.parse(decoded);\n      } catch {\n        /* empty */\n      }\n\n      return parsed;\n    },\n    format: 'application/x-slate-fragment',\n  },\n});\n","import { createSlatePlugin } from '../plugin';\n\n/**\n * Placeholder plugin for DOM interaction, that could be replaced with\n * ReactPlugin.\n */\nexport const DOMPlugin = createSlatePlugin({\n  key: 'dom',\n});\n","import { withHistory } from 'slate-history';\n\nimport type { SlateEditor } from '../editor';\n\nimport { type ExtendEditor, createSlatePlugin } from '../plugin';\n\nexport const withPlateHistory: ExtendEditor = ({ editor }) =>\n  withHistory(editor as any) as any as SlateEditor;\n\n/** @see {@link withHistory} */\nexport const HistoryPlugin = createSlatePlugin({\n  key: 'history',\n  extendEditor: withPlateHistory,\n});\n","import { type ExtendEditor, createSlatePlugin } from '../plugin';\n\n/**\n * Merge and register all the inline types and void types from the plugins and\n * options, using `editor.isInline`, `editor.markableVoid` and `editor.isVoid`\n */\nexport const withInlineVoid: ExtendEditor = ({ editor }) => {\n  const { isInline, isVoid, markableVoid } = editor;\n\n  const voidTypes: string[] = [];\n  const inlineTypes: string[] = [];\n  const markableVoidTypes: string[] = [];\n\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isInline) {\n      inlineTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isVoid) {\n      voidTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isMarkableVoid) {\n      markableVoidTypes.push(plugin.node.type);\n    }\n  });\n\n  editor.isInline = (element) => {\n    return inlineTypes.includes(element.type) ? true : isInline(element);\n  };\n\n  editor.isVoid = (element) => {\n    return voidTypes.includes(element.type) ? true : isVoid(element);\n  };\n\n  editor.markableVoid = (element) => {\n    return markableVoidTypes.includes(element.type)\n      ? true\n      : markableVoid(element);\n  };\n\n  return editor;\n};\n\n/** @see {@link withInlineVoid} */\nexport const InlineVoidPlugin = createSlatePlugin({\n  key: 'inlineVoid',\n  extendEditor: withInlineVoid,\n});\n","import {\n  type ExtendEditor,\n  createSlatePlugin,\n  getEditorPlugin,\n} from '../plugin';\nimport {\n  getInjectedPlugins,\n  pipeInsertDataQuery,\n  pipeInsertFragment,\n  pipeTransformData,\n  pipeTransformFragment,\n} from '../utils';\n\nexport const withParser: ExtendEditor = ({ editor }) => {\n  const { insertData } = editor;\n\n  editor.insertData = (dataTransfer) => {\n    const inserted = [...editor.pluginList].reverse().some((plugin) => {\n      const parser = plugin.parser;\n\n      if (!parser) return false;\n\n      const injectedPlugins = getInjectedPlugins(editor, plugin);\n      const { deserialize, format, mimeTypes } = parser;\n\n      if (!format) return false;\n\n      // Handle both string and string[] formats\n      const formats = Array.isArray(format) ? format : [format];\n      const mimeTypeList =\n        mimeTypes ||\n        formats.map((fmt) => (fmt.includes('/') ? fmt : `text/${fmt}`));\n\n      for (const mimeType of mimeTypeList) {\n        let data = dataTransfer.getData(mimeType);\n\n        if (!data) continue;\n        if (\n          !pipeInsertDataQuery(editor, injectedPlugins, {\n            data,\n            dataTransfer,\n          })\n        ) {\n          continue;\n        }\n\n        data = pipeTransformData(editor, injectedPlugins, {\n          data,\n          dataTransfer,\n        });\n\n        let fragment = deserialize?.({\n          ...getEditorPlugin(editor, plugin),\n          data,\n          dataTransfer,\n        });\n\n        if (!fragment?.length) continue;\n\n        fragment = pipeTransformFragment(editor, injectedPlugins, {\n          data,\n          dataTransfer,\n          fragment,\n        });\n\n        if (fragment.length === 0) continue;\n\n        pipeInsertFragment(editor, injectedPlugins, {\n          data,\n          dataTransfer,\n          fragment,\n        });\n\n        return true;\n      }\n\n      return false;\n    });\n\n    if (inserted) return;\n\n    insertData(dataTransfer);\n  };\n\n  return editor;\n};\n\nexport const ParserPlugin = createSlatePlugin({\n  key: 'parser',\n  extendEditor: withParser,\n});\n","import type { DebugConfig } from '../getCorePlugins';\n\nimport { createTSlatePlugin } from '../../plugin';\n\nexport type DebugErrorType =\n  | (string & {})\n  | 'DEFAULT'\n  | 'OPTION_UNDEFINED'\n  | 'OVERRIDE_MISSING'\n  | 'PLUGIN_DEPENDENCY_MISSING'\n  | 'PLUGIN_MISSING'\n  | 'USE_CREATE_PLUGIN'\n  | 'USE_ELEMENT_CONTEXT';\n\nexport class PlateError extends Error {\n  constructor(\n    message: string,\n    public type: DebugErrorType = 'DEFAULT'\n  ) {\n    super(`[${type}] ${message}`);\n    this.name = 'PlateError';\n  }\n}\n\nexport type LogLevel = 'error' | 'info' | 'log' | 'warn';\n\nexport const DebugPlugin = createTSlatePlugin<DebugConfig>({\n  key: 'debug',\n  options: {\n    isProduction: process.env.NODE_ENV === 'production',\n    logLevel:\n      process.env.NODE_ENV === 'production' ? 'error' : ('log' as LogLevel),\n    logger: {\n      error: (message, type, details) =>\n        console.error(`${type ? `[${type}] ` : ''}${message}`, details),\n      info: (message, type, details) =>\n        console.info(`${type ? `[${type}] ` : ''}${message}`, details),\n      log: (message, type, details) =>\n        console.log(`${type ? `[${type}] ` : ''}${message}`, details),\n      warn: (message, type, details) =>\n        console.warn(`${type ? `[${type}] ` : ''}${message}`, details),\n    },\n    throwErrors: true,\n  },\n}).extendEditorApi<DebugConfig['api']>(({ getOptions }) => {\n  const logLevels: LogLevel[] = ['error', 'warn', 'info', 'log'];\n\n  const log = (\n    level: LogLevel,\n    message: any,\n    type?: DebugErrorType,\n    details?: any\n  ) => {\n    const options = getOptions();\n\n    if (options.isProduction && level === 'log') return;\n    if (logLevels.indexOf(level) <= logLevels.indexOf(options.logLevel!)) {\n      if (level === 'error' && options.throwErrors) {\n        const error =\n          message instanceof Error ? message : new PlateError(message, type);\n\n        throw error;\n      } else {\n        options.logger[level]?.(message, type, details);\n      }\n    }\n  };\n\n  return {\n    debug: {\n      error: (message, type, details) => log('error', message, type, details),\n      info: (message, type, details) => log('info', message, type, details),\n      log: (message, type, details) => log('log', message, type, details),\n      warn: (message, type, details) => log('warn', message, type, details),\n    },\n  };\n});\n","import type { TDescendant, TElement, TRange, Value } from '@udecode/slate';\nimport type { Path } from 'slate';\n\nimport {\n  isSelectionAtBlockStart,\n  removeSelectionMark,\n  replaceNodeChildren,\n  toggleMark,\n} from '@udecode/slate-utils';\nimport { type OmitFirst, bindFirst } from '@udecode/utils';\n\nimport {\n  type ExtendEditor,\n  type PluginConfig,\n  createTSlatePlugin,\n} from '../../plugin';\nimport { resetEditor, toggleBlock } from '../../transforms';\nimport { BaseParagraphPlugin } from '../paragraph';\n\nexport type SlateNextConfig = PluginConfig<\n  'slateNext',\n  {},\n  {\n    create: {\n      block: (node?: Partial<TElement>, path?: Path) => TElement;\n      value: () => Value;\n    };\n    reset: () => void;\n  },\n  {\n    toggle: {\n      block: OmitFirst<typeof toggleBlock>;\n      mark: OmitFirst<typeof toggleMark>;\n    };\n  }\n>;\n\nexport const withSlateNext: ExtendEditor<SlateNextConfig> = ({ editor }) => {\n  const { apply, deleteBackward, deleteForward, deleteFragment } = editor;\n\n  editor.prevSelection = null;\n  editor.currentKeyboardEvent = null;\n\n  const resetMarks = () => {\n    if (isSelectionAtBlockStart(editor)) {\n      removeSelectionMark(editor);\n    }\n  };\n\n  editor.deleteBackward = (unit) => {\n    deleteBackward(unit);\n\n    resetMarks();\n  };\n\n  editor.deleteForward = (unit) => {\n    deleteForward(unit);\n\n    resetMarks();\n  };\n\n  editor.deleteFragment = (direction) => {\n    deleteFragment(direction);\n\n    resetMarks();\n  };\n\n  editor.apply = (operation) => {\n    if (operation.type === 'set_selection') {\n      const { properties } = operation;\n\n      editor.prevSelection = properties as TRange | null;\n\n      apply(operation);\n\n      editor.currentKeyboardEvent = null;\n\n      return;\n    }\n\n    apply(operation);\n  };\n\n  return editor;\n};\n\n/** Opinionated extension of slate default behavior. */\nexport const SlateNextPlugin = createTSlatePlugin<SlateNextConfig>({\n  key: 'slateNext',\n  extendEditor: withSlateNext,\n})\n  .extendEditorApi(({ editor }) => ({\n    create: {\n      /** Default block factory. */\n      block: (node?: Partial<TElement>, _path?: Path): TElement => ({\n        children: [{ text: '' }],\n        type: editor.getType(BaseParagraphPlugin),\n        ...node,\n      }),\n    },\n  }))\n  .extendEditorApi(({ api }) => ({\n    create: {\n      /** Editor children factory. */\n      value: (): Value => [api.create.block()],\n    },\n  }))\n  .extendEditorTransforms(({ editor }) => ({\n    reset: () => {\n      resetEditor(editor);\n    },\n    setValue: <V extends Value>(value?: V | string) => {\n      let children: TDescendant[] = value as any;\n\n      if (typeof value === 'string') {\n        children = editor.api.html.deserialize({\n          element: value,\n        });\n      } else if (!value || value.length === 0) {\n        children = editor.api.create.value();\n      }\n\n      replaceNodeChildren(editor, {\n        at: [],\n        nodes: children,\n      });\n    },\n    toggle: {\n      block: bindFirst(toggleBlock, editor),\n      mark: bindFirst(toggleMark, editor),\n    },\n  }));\n","import type { ElementOf } from '@udecode/slate';\n\nimport {\n  type ReplaceNodeChildrenOptions,\n  replaceNodeChildren,\n} from '@udecode/slate-utils';\n\nimport type { SlateEditor } from '../editor';\n\n/** Replace editor children by default block. */\nexport const resetEditorChildren = <E extends SlateEditor = SlateEditor>(\n  editor: E,\n  options?: Omit<ReplaceNodeChildrenOptions<ElementOf<E>, E>, 'at' | 'nodes'>\n) => {\n  replaceNodeChildren<ElementOf<E>>(editor, {\n    at: [],\n    nodes: editor.api.create.value(),\n    ...options,\n  } as any);\n};\n","import type { SlateEditor } from '../editor';\n\nimport { resetEditorChildren } from './resetEditorChildren';\n\nexport const resetEditor = (editor: SlateEditor) => {\n  resetEditorChildren(editor);\n\n  editor.history.undos = [];\n  editor.history.redos = [];\n  editor.operations = [];\n};\n","import {\n  type GetNodeEntriesOptions,\n  type TElement,\n  someNode,\n} from '@udecode/slate';\n\nimport type { SlateEditor } from '../editor';\n\nimport { type ToggleBlockOptions, BaseParagraphPlugin } from '../plugins';\n\n/**\n * Toggle the type of the selected block. If the block is not of the specified\n * type, it will be changed to that type. Otherwise, it will be changed to the\n * default type.\n */\nexport const toggleBlock = <E extends SlateEditor = SlateEditor>(\n  editor: E,\n  options: ToggleBlockOptions,\n  editorNodesOptions?: Omit<GetNodeEntriesOptions<E>, 'match'>\n) => {\n  const { defaultType = editor.getType(BaseParagraphPlugin), type } = options;\n\n  const at = editorNodesOptions?.at ?? editor.selection;\n\n  if (!type || !at) return;\n\n  const isActive = someNode(editor, {\n    ...editorNodesOptions,\n    match: {\n      type: type,\n    },\n  });\n\n  if (isActive && type === defaultType) return;\n\n  editor.setNodes<TElement>(\n    {\n      type: isActive ? defaultType : type,\n    },\n    { at: at as any }\n  );\n};\n","import { type PluginConfig, createSlatePlugin } from '../../plugin';\n\nexport type ParagraphConfig = PluginConfig<'p'>;\n\nexport const BaseParagraphPlugin = createSlatePlugin({\n  key: 'p',\n  node: { isElement: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query: ({ element }) => element.style.fontFamily !== 'Consolas',\n        rules: [\n          {\n            validNodeName: 'P',\n          },\n        ],\n      },\n    },\n  },\n});\n","import { bindFirst } from '@udecode/utils';\n\nimport { createSlatePlugin } from '../../plugin';\nimport { deserializeHtml, parseHtmlDocument } from './utils';\n\n/**\n * Enables support for deserializing inserted content from HTML format to Slate\n * format.\n */\nexport const HtmlPlugin = createSlatePlugin({\n  key: 'html',\n})\n  .extendApi(({ editor }) => ({\n    deserialize: bindFirst(deserializeHtml, editor),\n  }))\n  .extend({\n    parser: {\n      deserialize: ({ api, data }) => {\n        const document = parseHtmlDocument(data);\n\n        return api.html.deserialize({\n          element: document.body,\n        });\n      },\n      format: 'text/html',\n    },\n  });\n","export const CARRIAGE_RETURN = '\\u000D';\n\nexport const LINE_FEED = '\\u000A';\n\nexport const NO_BREAK_SPACE = '\\u00A0';\n\nexport const SPACE = '\\u0020';\n\nexport const TAB = '\\u0009';\n\nexport const ZERO_WIDTH_SPACE = '\\u200B';\n","export const isHtmlElement = (node: Node): node is Element =>\n  node.nodeType === Node.ELEMENT_NODE;\n","type Callback = (node: Node) => boolean;\n\n/**\n * Depth-first pre-order tree traverse the given HTML node and calls the given\n * callback for each node. see:\n * https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)\n *\n * @param callback Returns a boolean indicating whether traversal should be\n *   continued\n */\nexport const traverseHtmlNode = (node: Node, callback: Callback): void => {\n  const keepTraversing = callback(node);\n\n  if (!keepTraversing) {\n    return;\n  }\n\n  let child = node.firstChild;\n\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n\n    traverseHtmlNode(currentChild, callback);\n\n    if (\n      // An unwrap was made. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      previousChild !== child.previousSibling &&\n      child.parentNode\n    ) {\n      child = previousChild ? previousChild.nextSibling : node.firstChild;\n    } else if (\n      // A list was created. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      !child.previousSibling &&\n      !child.nextSibling &&\n      !child.parentNode\n    ) {\n      if (previousChild) {\n        child = previousChild.nextSibling\n          ? previousChild.nextSibling.nextSibling\n          : null;\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\n","import { isHtmlElement } from './isHtmlElement';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Element) => boolean;\n\n/**\n * Traverse the HTML elements of the given HTML node.\n *\n * @param rootNode The root HTML node to traverse.\n * @param callback The callback to call for each HTML element.\n */\nexport const traverseHtmlElements = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { LINE_FEED } from '../constants';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/** Replace BR elements with line feeds. */\nexport const cleanHtmlBrElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n\n    const replacementTextNode = document.createTextNode(LINE_FEED);\n\n    if (element.parentElement) {\n      element.parentElement.replaceChild(replacementTextNode, element);\n    }\n\n    return false;\n  });\n};\n","/** Replace \\r\\n and \\r with \\n */\nexport const cleanHtmlCrLf = (html: string): string => {\n  return html.replaceAll(/\\r\\n|\\r/g, '\\n');\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\nconst ALLOWED_EMPTY_ELEMENTS = new Set(['BR', 'IMG', 'TD', 'TH']);\n\nconst isEmpty = (element: Element): boolean => {\n  return (\n    !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim()\n  );\n};\n\nconst removeIfEmpty = (element: Element): void => {\n  if (isEmpty(element)) {\n    const { parentElement } = element;\n\n    element.remove();\n\n    if (parentElement) {\n      removeIfEmpty(parentElement);\n    }\n  }\n};\n\n/** Remove empty elements from rootNode. Allowed empty elements: BR, IMG. */\nexport const cleanHtmlEmptyElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    removeIfEmpty(element);\n\n    return true;\n  });\n};\n","/**\n * Replace `element` tag name by `tagName`. Attributes, innerHTML and parent\n * relationship is kept.\n */\nexport const replaceTagName = (element: Element, tagName: string): Element => {\n  const newElement = document.createElement(tagName);\n\n  newElement.innerHTML = element.innerHTML;\n\n  for (const { name } of element.attributes) {\n    const value = element.getAttribute(name);\n\n    if (value) {\n      newElement.setAttribute(name, value);\n    }\n  }\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(newElement, element);\n  }\n\n  return newElement;\n};\n","import { replaceTagName } from './replaceTagName';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Replace FONT elements with SPAN elements if there is textContent (remove\n * otherwise).\n */\nexport const cleanHtmlFontElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName === 'FONT') {\n      if (element.textContent) {\n        replaceTagName(element, 'span');\n      } else {\n        element.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","/** If href starts with '#'. */\nexport const isHtmlFragmentHref = (href: string): boolean =>\n  href.startsWith('#');\n","/** Unwrap the given HTML element. */\nexport const unwrapHtmlElement = (element: Element): void => {\n  element.outerHTML = element.innerHTML;\n};\n","import { isHtmlFragmentHref } from './isHtmlFragmentHref';\nimport { traverseHtmlElements } from './traverseHtmlElements';\nimport { unwrapHtmlElement } from './unwrapHtmlElement';\n\n/** Remove fragment hrefs and spans without inner text. */\nexport const cleanHtmlLinkElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'A') {\n      return true;\n    }\n\n    const href = element.getAttribute('href');\n\n    if (!href || isHtmlFragmentHref(href)) {\n      unwrapHtmlElement(element);\n    }\n    if (href && element.querySelector('img')) {\n      for (const span of element.querySelectorAll('span')) {\n        if (!span.textContent) {\n          unwrapHtmlElement(span);\n        }\n      }\n    }\n\n    return true;\n  });\n};\n","export const isHtmlText = (node: Node): node is Text =>\n  node.nodeType === Node.TEXT_NODE;\n","import { isHtmlText } from './isHtmlText';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Text) => boolean;\n\nexport const traverseHtmlTexts = (rootNode: Node, callback: Callback): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlText(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import {\n  CARRIAGE_RETURN,\n  LINE_FEED,\n  NO_BREAK_SPACE,\n  SPACE,\n} from '../constants';\nimport { traverseHtmlTexts } from './traverseHtmlTexts';\n\nexport const cleanHtmlTextNodes = (rootNode: Node): void => {\n  traverseHtmlTexts(rootNode, (textNode) => {\n    if (\n      /^\\n\\s*$/.test(textNode.data) &&\n      (textNode.previousElementSibling || textNode.nextElementSibling)\n    ) {\n      textNode.remove();\n\n      return true;\n    }\n\n    textNode.data = textNode.data.replaceAll(/\\n\\s*/g, '\\n');\n\n    if (\n      textNode.data.includes(CARRIAGE_RETURN) ||\n      textNode.data.includes(LINE_FEED) ||\n      textNode.data.includes(NO_BREAK_SPACE)\n    ) {\n      const hasSpace = textNode.data.includes(SPACE);\n      const hasNonWhitespace = /\\S/.test(textNode.data);\n      const hasLineFeed = textNode.data.includes(LINE_FEED);\n\n      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {\n        if (textNode.data === NO_BREAK_SPACE) {\n          textNode.data = SPACE;\n\n          return true;\n        }\n\n        textNode.remove();\n\n        return true;\n      }\n      if (\n        textNode.previousSibling &&\n        textNode.previousSibling.nodeName === 'BR' &&\n        textNode.parentElement\n      ) {\n        textNode.previousSibling.remove();\n\n        const matches = /^[\\n\\r]+/.exec(textNode.data);\n        const offset = matches ? matches[0].length : 0;\n\n        textNode.data = textNode.data\n          .slice(Math.max(0, offset))\n          .replaceAll(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replaceAll(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n        textNode.data = `\\n${textNode.data}`;\n      } else {\n        textNode.data = textNode.data\n          .replaceAll(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replaceAll(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n      }\n    }\n\n    return true;\n  });\n};\n","/**\n * # Methodology\n *\n * ## Step 1. Get the list of all standard tag names\n *\n * Go to https://developer.mozilla.org/en-US/docs/Web/HTML/Element and run the\n * following in the console to generate a JSON array of tag names:\n *\n * ```js\n * JSON.stringify(\n *   Array.from(document.querySelectorAll('article table td:first-child'))\n *     .map((td) => {\n *       const body = document.createElement('body');\n *       body.innerHTML = td.textContent;\n *       return body.firstChild?.tagName;\n *     })\n *     .filter((tagName) => tagName)\n * );\n * ```\n *\n * Output (as of 2023-11-06):\n *\n * ```json\n * '[\"BASE\",\"LINK\",\"META\",\"STYLE\",\"TITLE\",\"ADDRESS\",\"ARTICLE\",\"ASIDE\",\"FOOTER\",\"HEADER\",\"H1\",\"HGROUP\",\"MAIN\",\"NAV\",\"SECTION\",\"SEARCH\",\"BLOCKQUOTE\",\"DD\",\"DIV\",\"DL\",\"DT\",\"FIGCAPTION\",\"FIGURE\",\"HR\",\"LI\",\"MENU\",\"OL\",\"P\",\"PRE\",\"UL\",\"A\",\"ABBR\",\"B\",\"BDI\",\"BDO\",\"BR\",\"CITE\",\"CODE\",\"DATA\",\"DFN\",\"EM\",\"I\",\"KBD\",\"MARK\",\"Q\",\"RP\",\"RT\",\"RUBY\",\"S\",\"SAMP\",\"SMALL\",\"SPAN\",\"STRONG\",\"SUB\",\"SUP\",\"TIME\",\"U\",\"VAR\",\"WBR\",\"AREA\",\"AUDIO\",\"IMG\",\"MAP\",\"TRACK\",\"VIDEO\",\"EMBED\",\"IFRAME\",\"OBJECT\",\"PICTURE\",\"PORTAL\",\"SOURCE\",\"svg\",\"math\",\"CANVAS\",\"NOSCRIPT\",\"SCRIPT\",\"DEL\",\"INS\",\"TABLE\",\"BUTTON\",\"DATALIST\",\"FIELDSET\",\"FORM\",\"INPUT\",\"LABEL\",\"LEGEND\",\"METER\",\"OPTGROUP\",\"OPTION\",\"OUTPUT\",\"PROGRESS\",\"SELECT\",\"TEXTAREA\",\"DETAILS\",\"DIALOG\",\"SUMMARY\",\"SLOT\",\"TEMPLATE\",\"ACRONYM\",\"BIG\",\"CENTER\",\"CONTENT\",\"DIR\",\"FONT\",\"IMG\",\"MARQUEE\",\"MENUITEM\",\"NOBR\",\"NOEMBED\",\"NOFRAMES\",\"PARAM\",\"PLAINTEXT\",\"RB\",\"RTC\",\"SHADOW\",\"STRIKE\",\"TT\",\"XMP\"]'\n * ```\n *\n * ## Step 2. For each tag name, determine the default browser style\n *\n * Open an empty HTML file in the browser and run the following in the console:\n *\n * ```js\n * const tagNames = JSON.parse(<JSON string from step 1>);\n *\n * JSON.stringify(\n *   tagNames.filter((tagName) => {\n *     const element = document.createElement(tagName);\n *     document.body.appendChild(element);\n *     const display = window.getComputedStyle(element).display;\n *     element.remove();\n *     return display.startsWith('inline');\n *   })\n * );\n * ```\n *\n * Place the result in the array below (accurate as of 2023-11-06).\n */\n\nexport const inlineTagNames = new Set([\n  'A',\n  'ABBR',\n  'ACRONYM',\n  'B',\n  'BDI',\n  'BDO',\n  'BIG',\n  'BR',\n  'BUTTON',\n  'CANVAS',\n  'CITE',\n  'CODE',\n  'CONTENT',\n  'DATA',\n  'DEL',\n  'DFN',\n  'EM',\n  'EMBED',\n  'FONT',\n  'I',\n  'IFRAME',\n  'IMG',\n  'IMG',\n  'INPUT',\n  'INS',\n  'KBD',\n  'LABEL',\n  'MAP',\n  'MARK',\n  'MARQUEE',\n  'MENUITEM',\n  'METER',\n  'NOBR',\n  'OBJECT',\n  'OUTPUT',\n  'PICTURE',\n  'PORTAL',\n  'PROGRESS',\n  'Q',\n  'S',\n  'SAMP',\n  'SELECT',\n  'SHADOW',\n  'SMALL',\n  'SOURCE',\n  'SPAN',\n  'STRIKE',\n  'STRONG',\n  'SUB',\n  'SUP',\n  'TEXTAREA',\n  'TIME',\n  'TRACK',\n  'TT',\n  'U',\n  'VAR',\n  'VIDEO',\n  'WBR',\n  'math',\n  'svg',\n]);\n","import { inlineTagNames } from './inlineTagNames';\nimport { isHtmlElement } from './isHtmlElement';\n\nexport const isHtmlInlineElement = (node: Node): boolean => {\n  if (!isHtmlElement(node)) return false;\n\n  const element = node as HTMLElement;\n\n  const tagNameIsInline = inlineTagNames.has(element.tagName);\n\n  /**\n   * Valid display values include 'inline flow'. We only care about the first\n   * part.\n   */\n  const displayProperty = element.style.display.split(' ')[0];\n\n  if (displayProperty === '') {\n    return tagNameIsInline;\n  }\n  if (displayProperty.startsWith('inline')) {\n    return true;\n  }\n  if (displayProperty === 'inherit' && element.parentElement) {\n    return isHtmlInlineElement(element.parentElement);\n  }\n  /**\n   * Handle all special values manually, so that any unhandled values can be\n   * assumed to be block.\n   *\n   * Note: Ideally, content inside `display: none` elements should not be\n   * parsed. However, if such elements are parsed, it's best for their inline or\n   * block status to be left unchanged.\n   */\n  if (\n    ['contents', 'initial', 'none', 'revert', 'revert-layer', 'unset'].includes(\n      displayProperty\n    )\n  ) {\n    return tagNameIsInline;\n  }\n\n  return false;\n};\n","import { isHtmlElement } from './isHtmlElement';\nimport { isHtmlInlineElement } from './isHtmlInlineElement';\n\nexport const isHtmlBlockElement = (node: Node): boolean => {\n  if (!isHtmlElement(node)) return false;\n\n  const element = node as HTMLElement;\n\n  return !isHtmlInlineElement(element);\n};\n","export const isHtmlTable = (element: Element) => element.nodeName === 'TABLE';\n","import { isHtmlBlockElement } from './isHtmlBlockElement';\nimport { isHtmlTable } from './isHtmlTable';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Set HTML blocks mark styles to a new child span element if any. This allows\n * Plate to use block marks.\n */\nexport const copyBlockMarksToSpanChild = (rootNode: Node) => {\n  traverseHtmlElements(rootNode, (element) => {\n    const el = element as HTMLElement;\n\n    const styleAttribute = element.getAttribute('style');\n\n    if (!styleAttribute) return true;\n    if (isHtmlBlockElement(el) && !isHtmlTable(el)) {\n      const {\n        style: {\n          backgroundColor,\n          color,\n          fontFamily,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          textDecoration,\n        },\n      } = el;\n\n      if (\n        backgroundColor ||\n        color ||\n        fontFamily ||\n        fontSize ||\n        fontStyle ||\n        fontWeight ||\n        textDecoration\n      ) {\n        const span = document.createElement('span');\n\n        if (!['inherit', 'initial'].includes(color)) {\n          span.style.color = color;\n        }\n\n        span.style.fontFamily = fontFamily;\n        span.style.fontSize = fontSize;\n\n        if (!['inherit', 'initial', 'normal'].includes(color)) {\n          span.style.fontStyle = fontStyle;\n        }\n        if (![400, 'normal'].includes(fontWeight)) {\n          span.style.fontWeight = fontWeight;\n        }\n\n        span.style.textDecoration = textDecoration;\n\n        span.innerHTML = el.innerHTML;\n        element.innerHTML = span.outerHTML;\n      }\n    }\n\n    return true;\n  });\n};\n","import type { TrimEndRule, TrimStartRule } from './types';\n\nexport const collapseString = (\n  text: string,\n  {\n    shouldCollapseWhiteSpace = true,\n    trimEnd = 'collapse',\n    trimStart = 'collapse',\n    whiteSpaceIncludesNewlines = true,\n  }: {\n    shouldCollapseWhiteSpace?: boolean;\n    trimEnd?: TrimEndRule;\n    trimStart?: TrimStartRule;\n    whiteSpaceIncludesNewlines?: boolean;\n  } = {}\n) => {\n  if (trimStart === 'all') {\n    text = text.replace(/^\\s+/, '');\n  }\n  if (trimEnd === 'single-newline') {\n    // Strip at most one newline from the end\n    text = text.replace(/\\n$/, '');\n  }\n  if (shouldCollapseWhiteSpace) {\n    if (whiteSpaceIncludesNewlines) {\n      text = text.replaceAll(/\\s+/g, ' ');\n    } else {\n      // Collapse horizontal whitespace\n      text = text.replaceAll(/[^\\S\\n\\r]+/g, ' ');\n\n      /**\n       * Trim horizontal whitespace from the start and end of lines (behavior of\n       * pre-line).\n       */\n      text = text.replaceAll(/^[^\\S\\n\\r]+/gm, '');\n      text = text.replaceAll(/[^\\S\\n\\r]+$/gm, '');\n    }\n  }\n\n  return text;\n};\n","import { isHtmlBlockElement } from '../isHtmlBlockElement';\n\nexport const isLastNonEmptyTextOfInlineFormattingContext = (\n  initialText: Text\n): boolean => {\n  let currentNode: Node | null = initialText;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (currentNode.nextSibling) {\n      currentNode = currentNode.nextSibling;\n    } else {\n      // If there is no next sibling, ascend to the parent node\n      currentNode = currentNode.parentElement;\n\n      // If the parent node is a block, we've reached the end\n      if (currentNode && isHtmlBlockElement(currentNode)) {\n        return true;\n      }\n\n      // Otherwise, continue to the next sibling of the parent node\n      currentNode = currentNode?.nextSibling || null;\n    }\n    // If there's no next node, we've reached the end\n    if (!currentNode) {\n      return true;\n    }\n    // If the next node is a block, we've reached the end\n    if (isHtmlBlockElement(currentNode)) {\n      return true;\n    }\n    // If the next node is a non-empty text node, we're not at the end\n    if ((currentNode.textContent || '').length > 0) {\n      return false;\n    }\n\n    // Otherwise, continue to the next node\n  }\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nexport const upsertInlineFormattingContext = (\n  state: CollapseWhiteSpaceState\n) => {\n  if (state.inlineFormattingContext) {\n    state.inlineFormattingContext.atStart = false;\n  } else {\n    state.inlineFormattingContext = {\n      atStart: true,\n      lastHasTrailingWhiteSpace: false,\n    };\n  }\n};\n\nexport const endInlineFormattingContext = (state: CollapseWhiteSpaceState) => {\n  state.inlineFormattingContext = null;\n};\n","import type {\n  CollapseWhiteSpaceState,\n  TrimEndRule,\n  TrimStartRule,\n} from './types';\n\nimport { collapseString } from './collapseString';\nimport { isLastNonEmptyTextOfInlineFormattingContext } from './isLastNonEmptyTextOfInlineFormattingContext';\nimport { upsertInlineFormattingContext } from './stateTransforms';\n\nexport const collapseWhiteSpaceText = (\n  text: Text,\n  state: CollapseWhiteSpaceState\n) => {\n  const textContent = text.textContent || '';\n  const isWhiteSpaceOnly = textContent.trim() === '';\n\n  /**\n   * Do not start an inline formatting context with a text node containing only\n   * white space.\n   */\n  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {\n    upsertInlineFormattingContext(state);\n  }\n\n  const { whiteSpaceRule } = state;\n\n  /**\n   * Note: Due to the way HTML strings are parsed in htmlStringToDOMNode, up to\n   * one newline is already trimmed from the start of text nodes inside <pre>\n   * elements. If we do so again here, we may remove too many newlines. This\n   * only applies to actual <pre> elements, not elements with the white-space\n   * CSS property.\n   */\n  const trimStart: TrimStartRule = (() => {\n    if (whiteSpaceRule !== 'normal') return 'collapse';\n    if (\n      !state.inlineFormattingContext ||\n      state.inlineFormattingContext.atStart ||\n      state.inlineFormattingContext.lastHasTrailingWhiteSpace\n    )\n      return 'all';\n\n    return 'collapse';\n  })();\n\n  const trimEnd: TrimEndRule = (() => {\n    if (whiteSpaceRule === 'normal') return 'collapse';\n    if (isLastNonEmptyTextOfInlineFormattingContext(text))\n      return 'single-newline';\n\n    return 'collapse';\n  })();\n\n  const shouldCollapseWhiteSpace: boolean = {\n    normal: true,\n    pre: false,\n    'pre-line': true,\n  }[whiteSpaceRule];\n\n  const whiteSpaceIncludesNewlines = whiteSpaceRule !== 'pre-line';\n\n  const collapsedTextContent = collapseString(textContent || '', {\n    shouldCollapseWhiteSpace,\n    trimEnd,\n    trimStart,\n    whiteSpaceIncludesNewlines,\n  });\n\n  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {\n    state.inlineFormattingContext.lastHasTrailingWhiteSpace =\n      collapsedTextContent.endsWith(' ');\n  }\n\n  text.textContent = collapsedTextContent;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { isHtmlElement } from '../isHtmlElement';\nimport { isHtmlText } from '../isHtmlText';\nimport { collapseWhiteSpaceChildren } from './collapseWhiteSpaceChildren';\nimport { collapseWhiteSpaceElement } from './collapseWhiteSpaceElement';\nimport { collapseWhiteSpaceText } from './collapseWhiteSpaceText';\n\nexport const collapseWhiteSpaceNode = (\n  node: Node,\n  state: CollapseWhiteSpaceState\n) => {\n  if (isHtmlElement(node)) {\n    collapseWhiteSpaceElement(node as HTMLElement, state);\n\n    return;\n  }\n  if (isHtmlText(node)) {\n    collapseWhiteSpaceText(node as Text, state);\n\n    return;\n  }\n\n  collapseWhiteSpaceChildren(node, state);\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { collapseWhiteSpaceNode } from './collapseWhiteSpaceNode';\n\nexport const collapseWhiteSpaceChildren = (\n  node: Node,\n  state: CollapseWhiteSpaceState\n) => {\n  const childNodes = Array.from(node.childNodes);\n\n  for (const childNode of childNodes) {\n    collapseWhiteSpaceNode(childNode, state);\n  }\n};\n","import type { WhiteSpaceRule } from './types';\n\nexport const inferWhiteSpaceRule = (\n  element: HTMLElement\n): WhiteSpaceRule | null => {\n  const whiteSpaceProperty = element.style.whiteSpace;\n\n  switch (whiteSpaceProperty) {\n    case 'normal':\n    case 'nowrap': {\n      return 'normal';\n    }\n    case 'pre':\n    case 'pre-wrap':\n    case 'break-spaces': {\n      return 'pre';\n    }\n    case 'pre-line': {\n      return 'pre-line';\n    }\n  }\n\n  if (element.tagName === 'PRE') {\n    return 'pre';\n  }\n  if (whiteSpaceProperty === 'initial') {\n    return 'normal';\n  }\n\n  return null;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { isHtmlInlineElement } from '../isHtmlInlineElement';\nimport { collapseWhiteSpaceChildren } from './collapseWhiteSpaceChildren';\nimport { inferWhiteSpaceRule } from './inferWhiteSpaceRule';\nimport { endInlineFormattingContext } from './stateTransforms';\n\n/**\n * Note: We do not want to start an inline formatting context until we encounter\n * a text node.\n */\nexport const collapseWhiteSpaceElement = (\n  element: HTMLElement,\n  state: CollapseWhiteSpaceState\n) => {\n  const isInlineElement = isHtmlInlineElement(element);\n  const previousWhiteSpaceRule = state.whiteSpaceRule;\n  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);\n\n  if (inferredWhiteSpaceRule) {\n    state.whiteSpaceRule = inferredWhiteSpaceRule;\n  }\n  // End any existing inline formatting context\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n\n  collapseWhiteSpaceChildren(element, state);\n\n  // Do not let inline formatting context break out of block elements\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n\n  // Restore previous whiteSpaceRule\n  state.whiteSpaceRule = previousWhiteSpaceRule;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { collapseWhiteSpaceElement } from './collapseWhiteSpaceElement';\n\n// Entrypoint\nexport const collapseWhiteSpace = (element: HTMLElement) => {\n  const clonedElement = element.cloneNode(true) as HTMLElement;\n\n  // Mutable state object\n  const state: CollapseWhiteSpaceState = {\n    inlineFormattingContext: null,\n    whiteSpaceRule: 'normal',\n  };\n\n  collapseWhiteSpaceElement(clonedElement, state);\n\n  return clonedElement;\n};\n","import type { TDescendant } from '@udecode/slate';\n\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\n\njsx;\n\n/** Deserialize HTML body element to Fragment. */\nexport const htmlBodyToFragment = (\n  editor: SlateEditor,\n  element: HTMLElement\n): TDescendant[] | undefined => {\n  if (element.nodeName === 'BODY') {\n    return jsx(\n      'fragment',\n      {},\n      deserializeHtmlNodeChildren(editor, element)\n    ) as TDescendant[];\n  }\n};\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlChildren } from '../types';\n\nimport { deserializeHtmlNode } from './deserializeHtmlNode';\n\nexport const deserializeHtmlNodeChildren = (\n  editor: SlateEditor,\n  node: ChildNode | HTMLElement\n) =>\n  Array.from(node.childNodes).flatMap(\n    deserializeHtmlNode(editor)\n  ) as DeserializeHtmlChildren[];\n","/** Deserialize HTML to break line. */\nexport const htmlBrToNewLine = (node: ChildNode | HTMLElement) => {\n  if (node.nodeName === 'BR') {\n    return '\\n';\n  }\n};\n","import type { TDescendant } from '@udecode/slate';\n\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\nimport { pipeDeserializeHtmlElement } from './pipeDeserializeHtmlElement';\n\n/** Deserialize HTML to Element. */\nexport const htmlElementToElement = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  const deserialized = pipeDeserializeHtmlElement(editor, element);\n\n  if (deserialized) {\n    const { node, withoutChildren } = deserialized;\n\n    let descendants =\n      node.children ??\n      (deserializeHtmlNodeChildren(editor, element) as TDescendant[]);\n\n    if (descendants.length === 0 || withoutChildren) {\n      descendants = [{ text: '' }];\n    }\n\n    return jsx('element', node, descendants) as TDescendant;\n  }\n};\n","import { type AnyObject, isDefined } from '@udecode/utils';\nimport castArray from 'lodash/castArray.js';\n\nimport type { SlateEditor } from '../../../editor';\nimport type {\n  AnyEditorPlugin,\n  HtmlDeserializer,\n} from '../../../plugin/SlatePlugin';\nimport type { Nullable } from '../../../types';\n\nimport { getEditorPlugin } from '../../../plugin';\nimport { getInjectedPlugins } from '../../../utils/getInjectedPlugins';\n\n/** Get a deserializer by type, node names, class names and styles. */\nexport const pluginDeserializeHtml = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin,\n  {\n    deserializeLeaf,\n    element: el,\n  }: { element: HTMLElement; deserializeLeaf?: boolean }\n): (Nullable<HtmlDeserializer> & { node: AnyObject }) | undefined => {\n  const {\n    node: { isElement: isElementRoot, isLeaf: isLeafRoot, type },\n    parsers,\n  } = plugin;\n\n  const deserializer = parsers?.html?.deserializer;\n\n  if (!deserializer) return;\n\n  const {\n    attributeNames,\n    isElement: isElementRule,\n    isLeaf: isLeafRule,\n    query,\n    rules,\n  } = deserializer;\n  let { parse } = deserializer;\n\n  const isElement = isElementRule || isElementRoot;\n  const isLeaf = isLeafRule || isLeafRoot;\n\n  if (!deserializeLeaf && !isElement) {\n    return;\n  }\n  if (deserializeLeaf && !isLeaf) {\n    return;\n  }\n  if (rules) {\n    const isValid = rules.some(\n      ({ validAttribute, validClassName, validNodeName = '*', validStyle }) => {\n        if (validNodeName) {\n          const validNodeNames = castArray<string>(validNodeName);\n\n          // Ignore if el nodeName is not included in rule validNodeNames (except *).\n          if (\n            validNodeNames.length > 0 &&\n            !validNodeNames.includes(el.nodeName) &&\n            validNodeName !== '*'\n          )\n            return false;\n        }\n        // Ignore if the rule className is not in el class list.\n        if (validClassName && !el.classList.contains(validClassName))\n          return false;\n        if (validStyle) {\n          for (const [key, value] of Object.entries(validStyle)) {\n            const values = castArray<string>(value);\n\n            // Ignore if el style value is not included in rule style values (except *)\n            if (!values.includes((el.style as any)[key]) && value !== '*')\n              return;\n            // Ignore if el style value is falsy (for value *)\n            if (value === '*' && !(el.style as any)[key]) return;\n\n            const defaultNodeValue = plugin.inject.nodeProps?.defaultNodeValue;\n\n            // Ignore if the style value = plugin.inject.nodeProps.defaultNodeValue\n            if (\n              defaultNodeValue &&\n              defaultNodeValue === (el.style as any)[key]\n            ) {\n              return false;\n            }\n          }\n        }\n        if (validAttribute) {\n          if (typeof validAttribute === 'string') {\n            if (!el.getAttributeNames().includes(validAttribute)) return false;\n          } else {\n            for (const [attributeName, attributeValue] of Object.entries(\n              validAttribute\n            )) {\n              const attributeValues = castArray<string>(attributeValue);\n              const elAttribute = el.getAttribute(attributeName);\n\n              if (\n                !isDefined(elAttribute) ||\n                !attributeValues.includes(elAttribute)\n              )\n                return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    );\n\n    if (!isValid) return;\n  }\n  if (\n    query &&\n    !query({ ...(getEditorPlugin(editor, plugin) as any), element: el })\n  ) {\n    return;\n  }\n  if (!parse) {\n    if (isElement) {\n      parse = () => ({ type: type });\n    } else if (isLeaf) {\n      parse = () => ({ [type!]: true });\n    } else {\n      return;\n    }\n  }\n\n  let node =\n    parse({\n      ...(getEditorPlugin(editor, plugin) as any),\n      element: el,\n      node: {},\n    }) ?? {};\n\n  if (Object.keys(node).length === 0) return;\n\n  const injectedPlugins = getInjectedPlugins(editor, plugin);\n\n  injectedPlugins.forEach((injectedPlugin) => {\n    const res = injectedPlugin.parsers?.html?.deserializer?.parse?.({\n      ...(getEditorPlugin(editor, plugin) as any),\n      element: el,\n      node,\n    });\n\n    if (res) {\n      node = {\n        ...node,\n        ...res,\n      };\n    }\n  });\n\n  if (attributeNames) {\n    const elementAttributes = {};\n\n    const elementAttributeNames = el.getAttributeNames();\n\n    for (const elementAttributeName of elementAttributeNames) {\n      if (attributeNames.includes(elementAttributeName)) {\n        (elementAttributes as any)[elementAttributeName] =\n          el.getAttribute(elementAttributeName);\n      }\n    }\n\n    if (Object.keys(elementAttributes).length > 0) {\n      node.attributes = elementAttributes;\n    }\n  }\n\n  return { ...deserializer, node };\n};\n","import type { AnyObject } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { HtmlDeserializer } from '../../../plugin/SlatePlugin';\nimport type { Nullable } from '../../../types/misc/Nullable';\n\nimport { pluginDeserializeHtml } from './pluginDeserializeHtml';\n\nexport const pipeDeserializeHtmlElement = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  let result: (Nullable<HtmlDeserializer> & { node: AnyObject }) | undefined;\n\n  [...editor.pluginList].reverse().some((plugin) => {\n    result = pluginDeserializeHtml(editor, plugin, { element });\n\n    return !!result;\n  });\n\n  return result;\n};\n","import { type TDescendant, isElement, isText } from '@udecode/slate';\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { mergeDeepToNodes } from '../../../utils';\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\nimport { pipeDeserializeHtmlLeaf } from './pipeDeserializeHtmlLeaf';\n\n/**\n * Deserialize HTML to TDescendant[] with marks on Text. Build the leaf from the\n * leaf deserializers of each plugin.\n */\nexport const htmlElementToLeaf = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  const node = pipeDeserializeHtmlLeaf(editor, element);\n\n  return deserializeHtmlNodeChildren(editor, element).reduce(\n    (arr: TDescendant[], child) => {\n      if (!child) return arr;\n      if (isElement(child)) {\n        if (Object.keys(node).length > 0) {\n          mergeDeepToNodes({\n            node: child,\n            query: {\n              filter: ([n]) => isText(n),\n            },\n            source: node,\n          });\n        }\n\n        arr.push(child);\n      } else {\n        const attributes = { ...node };\n\n        // attributes should not override child attributes\n        if (isText(child) && child.text) {\n          Object.keys(attributes).forEach((key) => {\n            if (attributes[key] && child[key]) {\n              attributes[key] = child[key];\n            }\n          });\n        }\n\n        arr.push(jsx('text', attributes, child) as any);\n      }\n\n      return arr;\n    },\n    []\n  ) as TDescendant[];\n};\n","import type { AnyObject } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { pluginDeserializeHtml } from './pluginDeserializeHtml';\n\nexport const pipeDeserializeHtmlLeaf = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  let node: AnyObject = {};\n\n  [...editor.pluginList].reverse().forEach((plugin) => {\n    const deserialized = pluginDeserializeHtml(editor, plugin, {\n      deserializeLeaf: true,\n      element,\n    });\n\n    if (!deserialized) return;\n\n    node = { ...node, ...deserialized.node };\n  });\n\n  return node;\n};\n","/** Deserialize HTML text node to text. */\nimport { isHtmlText } from './isHtmlText';\n\nexport const htmlTextNodeToString = (node: ChildNode | HTMLElement) => {\n  if (isHtmlText(node)) {\n    return node.textContent || '';\n  }\n};\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlNodeReturnType } from '../types';\n\nimport { htmlBodyToFragment } from './htmlBodyToFragment';\nimport { htmlBrToNewLine } from './htmlBrToNewLine';\nimport { htmlElementToElement } from './htmlElementToElement';\nimport { htmlElementToLeaf } from './htmlElementToLeaf';\nimport { htmlTextNodeToString } from './htmlTextNodeToString';\nimport { isHtmlElement } from './isHtmlElement';\n\n/** Deserialize HTML element or child node. */\nexport const deserializeHtmlNode =\n  (editor: SlateEditor) =>\n  (node: ChildNode | HTMLElement): DeserializeHtmlNodeReturnType => {\n    const textNode = htmlTextNodeToString(node);\n\n    if (textNode) return textNode;\n    if (!isHtmlElement(node)) return null;\n\n    // break line\n    const breakLine = htmlBrToNewLine(node);\n\n    if (breakLine) return breakLine;\n\n    // body\n    const fragment = htmlBodyToFragment(editor, node as HTMLElement);\n\n    if (fragment) return fragment;\n\n    // element\n    const element = htmlElementToElement(editor, node as HTMLElement);\n\n    if (element) return element;\n\n    // leaf\n    return htmlElementToLeaf(editor, node as HTMLElement);\n  };\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlNodeReturnType } from '../types';\n\nimport { deserializeHtmlNode } from './deserializeHtmlNode';\n\n/** Deserialize HTML element to fragment. */\nexport const deserializeHtmlElement = (\n  editor: SlateEditor,\n  element: HTMLElement\n): DeserializeHtmlNodeReturnType => {\n  return deserializeHtmlNode(editor)(element);\n};\n","/** Convert HTML string into HTML element. */\nexport const htmlStringToDOMNode = (rawHtml: string) => {\n  const node = document.createElement('body');\n  node.innerHTML = rawHtml;\n\n  return node;\n};\n","import type { TDescendant } from '@udecode/slate';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { normalizeDescendantsToDocumentFragment } from '../../../utils/normalizeDescendantsToDocumentFragment';\nimport { collapseWhiteSpace } from './collapse-white-space';\nimport { deserializeHtmlElement } from './deserializeHtmlElement';\nimport { htmlStringToDOMNode } from './htmlStringToDOMNode';\n\n/** Deserialize HTML element to a valid document fragment. */\nexport const deserializeHtml = (\n  editor: SlateEditor,\n  {\n    collapseWhiteSpace: shouldCollapseWhiteSpace = true,\n    element,\n  }: {\n    element: HTMLElement | string;\n    collapseWhiteSpace?: boolean;\n  }\n): TDescendant[] => {\n  // for serializer\n  if (typeof element === 'string') {\n    element = htmlStringToDOMNode(element);\n  }\n  if (shouldCollapseWhiteSpace) {\n    element = collapseWhiteSpace(element);\n  }\n\n  const fragment = deserializeHtmlElement(editor, element) as TDescendant[];\n\n  return normalizeDescendantsToDocumentFragment(editor, {\n    descendants: fragment,\n  });\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Find the first HTML element that matches the given selector.\n *\n * @param rootNode\n * @param predicate\n */\nexport const findHtmlElement = (\n  rootNode: Node,\n  predicate: (node: HTMLElement) => boolean\n) => {\n  let res: Node | null = null;\n\n  traverseHtmlElements(rootNode, (node) => {\n    if (predicate(node as HTMLElement)) {\n      res = node;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  return res;\n};\n\nexport const someHtmlElement = (\n  rootNode: Node,\n  predicate: (node: HTMLElement) => boolean\n) => {\n  return !!findHtmlElement(rootNode, predicate);\n};\n","const acceptNode = () => NodeFilter.FILTER_ACCEPT;\n\nexport const getHtmlComments = (node: Node): string[] => {\n  const comments: string[] = [];\n  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode,\n  });\n  let currentNode = iterator.nextNode();\n\n  while (currentNode) {\n    if (currentNode.nodeValue) {\n      comments.push(currentNode.nodeValue);\n    }\n\n    currentNode = iterator.nextNode();\n  }\n\n  return comments;\n};\n","export const isHtmlComment = (node: Node): node is Comment =>\n  node.nodeType === Node.COMMENT_NODE;\n","export const isOlSymbol = (symbol: string): boolean => {\n  return /[\\da-np-z]\\S/.test(symbol.toLowerCase());\n};\n","export const parseHtmlDocument = (html: string) => {\n  return new DOMParser().parseFromString(html, 'text/html');\n};\n","import { parseHtmlDocument } from './parseHtmlDocument';\n\nexport const parseHtmlElement = (html: string) => {\n  const { body } = parseHtmlDocument(html);\n\n  return body.firstElementChild as HTMLElement;\n};\n","import { ZERO_WIDTH_SPACE } from '../constants';\n\n/** Trim the html and remove zero width spaces, then wrap it with a body element. */\nexport const postCleanHtml = (html: string): string => {\n  const cleanHtml = html\n    .trim()\n    .replaceAll(new RegExp(ZERO_WIDTH_SPACE, 'g'), '');\n\n  return `<body>${cleanHtml}</body>`;\n};\n","/** Remove string before <html */\nconst removeBeforeHtml = (html: string): string => {\n  const index = html.indexOf('<html');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.slice(Math.max(0, index));\n};\n\n/** Remove string after </html> */\nconst removeAfterHtml = (html: string): string => {\n  const index = html.lastIndexOf('</html>');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.slice(0, Math.max(0, index + '</html>'.length));\n};\n\n/** Remove string before <html and after </html> */\nexport const removeHtmlSurroundings = (html: string): string => {\n  return removeBeforeHtml(removeAfterHtml(html));\n};\n","import { cleanHtmlCrLf } from './cleanHtmlCrLf';\nimport { removeHtmlSurroundings } from './removeHtmlSurroundings';\n\nconst cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];\n\n/** Remove HTML surroundings and clean HTML from CR/LF */\nexport const preCleanHtml = (html: string): string => {\n  return cleaners.reduce((result, clean) => clean(result), html);\n};\n","import { isHtmlComment } from './isHtmlComment';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Comment) => boolean;\n\n/** Traverse HTML comments. */\nexport const traverseHtmlComments = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlComment(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { isHtmlComment } from './isHtmlComment';\nimport { traverseHtmlComments } from './traverseHtmlComments';\n\n/** Removes HTML nodes between HTML comments. */\nexport const removeHtmlNodesBetweenComments = (\n  rootNode: Node,\n  start: string,\n  end: string\n): void => {\n  const isClosingComment = (node: Node) =>\n    isHtmlComment(node) && node.data === end;\n\n  traverseHtmlComments(rootNode, (comment) => {\n    if (comment.data === start) {\n      let node = comment.nextSibling;\n\n      comment.remove();\n\n      while (node && !isClosingComment(node)) {\n        const { nextSibling } = node;\n        node.remove();\n        node = nextSibling;\n      }\n\n      if (node && isClosingComment(node)) {\n        node.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","import { getEditorString, withoutNormalizing } from '@udecode/slate';\n\nimport type { LengthConfig } from '../getCorePlugins';\n\nimport { type ExtendEditor, createTSlatePlugin } from '../../plugin';\n\nexport const withLength: ExtendEditor<LengthConfig> = ({\n  editor,\n  getOptions,\n}) => {\n  const { apply } = editor;\n\n  editor.apply = (operation) => {\n    withoutNormalizing(editor, () => {\n      apply(operation);\n\n      const options = getOptions();\n\n      if (options.maxLength) {\n        const length = getEditorString(editor, []).length;\n\n        // Make sure to remove overflow of text beyond character limit\n        if (length > options.maxLength) {\n          const overflowLength = length - options.maxLength;\n\n          editor.delete({\n            distance: overflowLength,\n            reverse: true,\n            unit: 'character',\n          });\n        }\n      }\n    });\n  };\n\n  return editor;\n};\n\nexport const LengthPlugin = createTSlatePlugin<LengthConfig>({\n  key: 'length',\n  extendEditor: withLength,\n});\n","import type { AnyPluginConfig, PluginConfig } from '../plugin/BasePlugin';\nimport type { SlatePlugin } from '../plugin/SlatePlugin';\n\nimport {\n  createSlatePlugin,\n  createTSlatePlugin,\n} from '../plugin/createSlatePlugin';\nimport { AstPlugin } from './AstPlugin';\nimport { DOMPlugin } from './DOMPlugin';\nimport { HistoryPlugin } from './HistoryPlugin';\nimport { InlineVoidPlugin } from './InlineVoidPlugin';\nimport { ParserPlugin } from './ParserPlugin';\nimport { type DebugErrorType, type LogLevel, DebugPlugin } from './debug';\nimport { SlateNextPlugin } from './editor-protocol';\nimport { HtmlPlugin } from './html';\nimport { LengthPlugin } from './length';\nimport { BaseParagraphPlugin } from './paragraph';\n\n// Somehow needed to avoid cyclic dependency\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst _ = () => {\n  createSlatePlugin();\n  createTSlatePlugin();\n};\n\nexport type CorePlugin = ReturnType<typeof getCorePlugins>[number];\n\nexport type GetCorePluginsOptions = {\n  /** Specifies the maximum number of characters allowed in the editor. */\n  maxLength?: number;\n\n  /** Override the core plugins using the same key. */\n  plugins?: AnyPluginConfig[];\n};\n\nexport const getCorePlugins = ({\n  maxLength,\n  plugins = [],\n}: GetCorePluginsOptions) => {\n  let corePlugins = [\n    DebugPlugin as SlatePlugin<DebugConfig>,\n    SlateNextPlugin,\n    DOMPlugin,\n    HistoryPlugin,\n    InlineVoidPlugin,\n    ParserPlugin,\n    maxLength\n      ? LengthPlugin.configure({\n          options: { maxLength },\n        })\n      : LengthPlugin,\n    HtmlPlugin,\n    AstPlugin,\n    BaseParagraphPlugin,\n  ];\n\n  // Create a map for quick lookup of custom plugins\n  const customPluginsMap = new Map(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n\n  // Replace core plugins with custom plugins if they exist and remove them from plugins\n  corePlugins = corePlugins.map((corePlugin) => {\n    const customPlugin = customPluginsMap.get(corePlugin.key);\n\n    if (customPlugin) {\n      // Remove the custom plugin from the plugins array\n      const index = plugins.findIndex((p) => p.key === corePlugin.key);\n\n      if (index !== -1) {\n        plugins.splice(index, 1);\n      }\n\n      return customPlugin;\n    }\n\n    return corePlugin as any;\n  });\n\n  return corePlugins;\n};\n\ntype LogFunction = (\n  message: string,\n  type?: DebugErrorType,\n  details?: any\n) => void;\n\nexport type DebugConfig = PluginConfig<\n  'debug',\n  {\n    isProduction: boolean;\n    logLevel: LogLevel;\n    logger: Partial<Record<LogLevel, LogFunction>>;\n    throwErrors: boolean;\n  },\n  {\n    debug: {\n      error: (\n        message: string | unknown,\n        type?: DebugErrorType,\n        details?: any\n      ) => void;\n      info: (message: string, type?: DebugErrorType, details?: any) => void;\n      log: (message: string, type?: DebugErrorType, details?: any) => void;\n      warn: (message: string, type?: DebugErrorType, details?: any) => void;\n    };\n  }\n>;\n\nexport type LengthConfig = PluginConfig<\n  'length',\n  {\n    maxLength: number;\n  }\n>;\n\nexport interface ToggleBlockOptions {\n  /** The default block type to revert to when untoggling. Defaults to paragraph. */\n  defaultType?: string;\n\n  /** The block type to apply or toggle. */\n  type?: string;\n}\n","import defaultsDeep from 'lodash/defaultsDeep.js';\n\nimport type { AnySlatePlugin } from '../plugin/SlatePlugin';\n\n/**\n * Recursive deep merge of each plugin from `override.plugins` into plugin with\n * same key (plugin > plugin.plugins).\n */\nexport const overridePluginsByKey = (\n  plugin: AnySlatePlugin,\n  overrideByKey: Record<string, Partial<AnySlatePlugin>> = {},\n  nested = false\n): AnySlatePlugin => {\n  if (overrideByKey[plugin.key]) {\n    const {\n      __extensions: pluginOverridesExtensions,\n      plugins: pluginOverridesPlugins,\n      ...pluginOverrides\n    } = overrideByKey[plugin.key];\n\n    // Override plugin\n    plugin = defaultsDeep({}, pluginOverrides, plugin);\n\n    // Merge __extensions\n    if (pluginOverridesExtensions) {\n      plugin.__extensions = [\n        ...(plugin.__extensions || []),\n        ...pluginOverridesExtensions,\n      ];\n    }\n    if (!nested) {\n      // Concat new pluginOverrides.plugins to plugin.plugins\n      pluginOverridesPlugins?.forEach((pOverrides) => {\n        if (!plugin.plugins) plugin.plugins = [];\n\n        const found = plugin.plugins.find((p) => p.key === pOverrides.key);\n\n        if (!found) plugin.plugins.push(pOverrides);\n      });\n    }\n  }\n  if (plugin.plugins) {\n    // Override plugin.plugins\n    plugin.plugins = plugin.plugins.map((p) =>\n      overridePluginsByKey(p, overrideByKey, true)\n    );\n  }\n\n  return plugin;\n};\n","import { type TElement, type TText, isElement } from '@udecode/slate';\nimport { type AnyObject, isDefined } from '@udecode/utils';\nimport { clsx } from 'clsx';\n\nimport type { SlateEditor } from '../editor';\nimport type { EditorPlugin, TransformOptions } from '../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../plugin';\nimport { getKeyByType } from './getKeysByTypes';\n\nexport interface GetInjectNodePropsOptions {\n  /** Existing className. */\n  className?: string;\n\n  /** Style value or className key. */\n  element?: TElement;\n\n  /** Existing style. */\n  style?: CSSStyleDeclaration;\n\n  /** Style value or className key. */\n  text?: TText;\n}\n\nexport interface GetInjectNodePropsReturnType extends AnyObject {\n  className?: string;\n  style?: CSSStyleDeclaration;\n}\n\n/**\n * Return if `element`, `text`, `nodeKey` is defined. Return if `node.type` is\n * not in `targetPlugins` (if defined). Return if `value = node[nodeKey]` is not\n * in `validNodeValues` (if defined). If `classNames[value]` is defined,\n * override `className` with it. If `styleKey` is defined, override `style` with\n * `[styleKey]: value`.\n */\nexport const pluginInjectNodeProps = (\n  editor: SlateEditor,\n  plugin: EditorPlugin,\n  nodeProps: GetInjectNodePropsOptions\n): GetInjectNodePropsReturnType | undefined => {\n  const {\n    key,\n    inject: { nodeProps: injectNodeProps, targetPlugins },\n  } = plugin;\n\n  const { className, element, style, text } = nodeProps;\n\n  const node = element ?? text;\n\n  if (!node) return;\n  if (!injectNodeProps) return;\n\n  const {\n    classNames,\n    defaultNodeValue,\n    nodeKey = key,\n    query,\n    styleKey = nodeKey as any,\n    transformClassName,\n    transformNodeValue,\n    transformProps,\n    transformStyle,\n    validNodeValues,\n  } = injectNodeProps;\n\n  const queryResult = query?.({\n    ...injectNodeProps,\n    ...(getEditorPlugin(editor, plugin) as any),\n    nodeProps,\n  });\n\n  if (\n    !queryResult &&\n    targetPlugins &&\n    isElement(node) &&\n    node.type &&\n    !targetPlugins.includes(getKeyByType(editor, node.type))\n  ) {\n    return;\n  }\n\n  const nodeValue = node[nodeKey!] as any;\n\n  // early return if there is no reason to inject props\n  if (\n    !queryResult &&\n    (!isDefined(nodeValue) ||\n      (validNodeValues && !validNodeValues.includes(nodeValue)) ||\n      nodeValue === defaultNodeValue)\n  ) {\n    return;\n  }\n\n  const transformOptions: TransformOptions = {\n    ...nodeProps,\n    ...(getEditorPlugin(editor, plugin) as any),\n    nodeValue,\n  };\n  const value = transformNodeValue?.(transformOptions) ?? nodeValue;\n  transformOptions.value = value;\n\n  let res: GetInjectNodePropsReturnType = {};\n\n  if (element) {\n    res.className = clsx(className, `slate-${nodeKey}-${nodeValue}`);\n  }\n  if (classNames?.[nodeValue] || transformClassName) {\n    res.className =\n      transformClassName?.(transformOptions) ??\n      clsx(className, classNames?.[value]);\n  }\n  if (styleKey) {\n    res.style =\n      transformStyle?.(transformOptions) ??\n      ({\n        ...style,\n        [styleKey as string]: value,\n      } as any);\n  }\n  if (transformProps) {\n    res = transformProps({ ...transformOptions, props: res }) ?? res;\n  }\n\n  return res;\n};\n","import type { SlateEditor } from '../editor';\n\nimport { pluginInjectNodeProps } from './pluginInjectNodeProps';\n\n/** Inject plugin props, editor. */\nexport const pipeInjectNodeProps = (editor: SlateEditor, nodeProps: any) => {\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.inject.nodeProps) {\n      const props = pluginInjectNodeProps(editor, plugin, nodeProps);\n\n      if (props) {\n        nodeProps = {\n          ...nodeProps,\n          ...props,\n        };\n      }\n    }\n  });\n\n  return { ...nodeProps, editor };\n};\n","import type { SlateEditor } from '../editor';\nimport type { ParserOptions } from '../plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../plugin';\n\n/** Is the plugin disabled by another plugin. */\nexport const pipeInsertDataQuery = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { data, dataTransfer }: ParserOptions\n) =>\n  plugins.every((p) => {\n    const query = p.parser?.query;\n\n    return (\n      !query ||\n      query({\n        ...getEditorPlugin(editor, p as any),\n        data,\n        dataTransfer,\n      })\n    );\n  });\n","import { type TDescendant, withoutNormalizing } from '@udecode/slate';\n\nimport type { SlateEditor } from '../editor';\nimport type { ParserOptions } from '../plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../plugin';\n\n/** Pipe preInsert then insertFragment. */\nexport const pipeInsertFragment = (\n  editor: SlateEditor,\n  injectedPlugins: Partial<AnyEditorPlugin>[],\n  { fragment, ...options }: ParserOptions & { fragment: TDescendant[] }\n) => {\n  withoutNormalizing(editor, () => {\n    injectedPlugins.some((p) => {\n      return (\n        p.parser?.preInsert?.({\n          ...getEditorPlugin(editor, p as any),\n          fragment,\n          ...options,\n        }) === true\n      );\n    });\n\n    editor.insertFragment(fragment);\n  });\n};\n","import cloneDeep from 'lodash/cloneDeep.js';\nimport isEqual from 'lodash/isEqual.js';\n\nimport type { SlateEditor } from '../editor';\n\nimport { getEditorPlugin } from '../plugin';\n\n/** Normalize initial value from editor plugins. Set into plate store if diff. */\nexport const pipeNormalizeInitialValue = (editor: SlateEditor) => {\n  const value = editor.children;\n  let normalizedValue = cloneDeep(value);\n\n  editor.pluginList.forEach((p) => {\n    const _normalizedValue = p.normalizeInitialValue?.({\n      ...getEditorPlugin(editor, p),\n      value: normalizedValue,\n    } as any);\n\n    if (_normalizedValue) {\n      normalizedValue = _normalizedValue;\n    }\n  });\n\n  if (!isEqual(value, normalizedValue) && normalizedValue) {\n    editor.children = normalizedValue;\n  }\n};\n","import type { SlateEditor } from '../editor';\nimport type { ParserOptions } from '../plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../plugin';\n\n/** Pipe editor.insertData.transformData */\nexport const pipeTransformData = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { data, dataTransfer }: ParserOptions\n) => {\n  plugins.forEach((p) => {\n    const transformData = p.parser?.transformData;\n\n    if (!transformData) return;\n\n    data = transformData({\n      ...getEditorPlugin(editor, p as any),\n      data,\n      dataTransfer,\n    });\n  });\n\n  return data;\n};\n","import type { TDescendant } from '@udecode/slate';\n\nimport type { SlateEditor } from '../editor';\nimport type { ParserOptions } from '../plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../plugin';\n\n/** Pipe editor.insertData.transformFragment */\nexport const pipeTransformFragment = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { fragment, ...options }: ParserOptions & { fragment: TDescendant[] }\n) => {\n  plugins.forEach((p) => {\n    const transformFragment = p.parser?.transformFragment;\n\n    if (!transformFragment) return;\n\n    fragment = transformFragment({\n      fragment,\n      ...options,\n      ...getEditorPlugin(editor, p as any),\n    });\n  });\n\n  return fragment;\n};\n","import merge from 'lodash/merge.js';\n\nimport type { SlateEditor } from '../editor';\nimport type { PluginConfig } from '../plugin/BasePlugin';\nimport type { AnySlatePlugin, SlatePlugin } from '../plugin/SlatePlugin';\n\nimport { mergePlugins } from '../../internal/mergePlugins';\nimport { getEditorPlugin } from '../plugin';\n\n/**\n * Resolves and finalizes a plugin configuration for use in a Plate editor.\n *\n * This function processes a given plugin configuration, applying any extensions\n * and resolving nested plugins. It prepares the plugin for integration into the\n * Plate editor system by:\n *\n * 1. Cloning the plugin to avoid mutating the original\n * 2. Applying all stored extensions to the plugin\n * 3. Clearing the extensions array after application\n *\n * @example\n *   const plugin = createSlatePlugin({ key: 'myPlugin', ...otherOptions }).extend(...);\n *   const resolvedPlugin = resolvePlugin(editor, plugin);\n */\nexport const resolvePlugin = <P extends AnySlatePlugin>(\n  editor: SlateEditor,\n  _plugin: P\n): P => {\n  // Create a deep clone of the plugin\n  let plugin = mergePlugins({}, _plugin) as P;\n\n  plugin.__resolved = true;\n\n  // Apply the stored configuration first\n  if (plugin.__configuration) {\n    const configResult = plugin.__configuration(\n      getEditorPlugin(editor, plugin as any)\n    );\n\n    plugin = mergePlugins(plugin, configResult);\n\n    delete (plugin as any).__configuration;\n  }\n  // Apply all stored extensions\n  if (plugin.__extensions && plugin.__extensions.length > 0) {\n    plugin.__extensions.forEach((extension) => {\n      plugin = mergePlugins(\n        plugin,\n        extension(getEditorPlugin(editor, plugin as any))\n      );\n    });\n    plugin.__extensions = [];\n  }\n\n  const targetPluginToInject = plugin.inject?.targetPluginToInject;\n  const targetPlugins = plugin.inject?.targetPlugins;\n\n  if (targetPluginToInject && targetPlugins && targetPlugins.length > 0) {\n    plugin.inject = plugin.inject || {};\n    plugin.inject.plugins = merge(\n      {},\n      plugin.inject.plugins,\n      Object.fromEntries(\n        targetPlugins.map((targetPlugin) => {\n          const injectedPlugin = targetPluginToInject({\n            ...getEditorPlugin(editor, plugin as any),\n            targetPlugin,\n          });\n\n          return [targetPlugin, injectedPlugin];\n        })\n      )\n    );\n  }\n  // TODO React\n  if ((plugin as any).node?.component) {\n    (plugin as any).render.node = (plugin as any).node.component;\n  }\n  if ((plugin as any).render?.node) {\n    (plugin as any).node.component = (plugin as any).render.node;\n  }\n\n  validatePlugin(editor, plugin);\n\n  return plugin;\n};\n\nexport const validatePlugin = <K extends string = any, O = {}, A = {}, T = {}>(\n  editor: SlateEditor,\n  plugin: SlatePlugin<PluginConfig<K, O, A, T>>\n) => {\n  if (!plugin.__extensions) {\n    editor.api.debug.error(\n      `Invalid plugin '${plugin.key}', you should use createSlatePlugin.`,\n      'USE_CREATE_PLUGIN'\n    );\n  }\n  if (plugin.node.isElement && plugin.node.isLeaf) {\n    editor.api.debug.error(\n      `Plugin ${plugin.key} cannot be both an element and a leaf.`,\n      'PLUGIN_NODE_TYPE'\n    );\n  }\n};\n","import type { AnyPluginConfig } from '../plugin/BasePlugin';\n\nimport { createSlateEditor } from '../editor';\nimport { createSlatePlugin } from '../plugin/createSlatePlugin';\nimport { resolvePlugin } from './resolvePlugin';\n\nexport const resolvePluginTest = <P extends AnyPluginConfig>(p: P) => {\n  const editor = createSlateEditor({\n    plugins: [p],\n  }) as any;\n\n  let key = p.key;\n\n  if (!key) {\n    key = resolvePlugin(editor, p as any).key;\n  }\n\n  return editor.plugins[key];\n};\n\nexport const resolveCreatePluginTest = ((plugin: AnyPluginConfig) => {\n  const p = createSlatePlugin(plugin);\n\n  const editor = createSlateEditor({\n    plugins: [p],\n  }) as any;\n\n  let key = p.key;\n\n  if (!key) {\n    key = resolvePlugin(editor, p as any).key;\n  }\n\n  return editor.plugins[key];\n}) as typeof createSlatePlugin;\n","import { isDefined } from '@udecode/utils';\nimport merge from 'lodash/merge.js';\nimport { createZustandStore } from 'zustand-x';\n\nimport type { SlateEditor } from '../editor';\n\nimport { mergePlugins } from '../../internal/mergePlugins';\nimport {\n  type SlatePlugin,\n  type SlatePlugins,\n  getEditorPlugin,\n} from '../plugin';\nimport { resolvePlugin } from './resolvePlugin';\n\n/**\n * Initialize and configure the editor's plugin system. This function sets up\n * the editor's plugins, resolving core and custom plugins, and applying any\n * overrides specified in the plugins.\n */\nexport const resolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins = []\n) => {\n  editor.pluginList = [];\n  editor.plugins = {};\n  editor.api = {} as any;\n  editor.transforms = {} as any;\n  editor.tf = editor.transforms;\n  editor.shortcuts = {} as any;\n\n  const resolvedPlugins = resolveAndSortPlugins(editor, plugins);\n\n  applyPluginsToEditor(editor, resolvedPlugins);\n\n  resolvePluginOverrides(editor);\n\n  resolvePluginStores(editor);\n\n  resolvePluginApis(editor);\n\n  // extendEditor\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.extendEditor) {\n      editor = plugin.extendEditor(getEditorPlugin(editor, plugin) as any);\n    }\n  });\n\n  return editor;\n};\n\nconst resolvePluginStores = (editor: SlateEditor) => {\n  // Create zustand stores for each plugin\n  editor.pluginList.forEach((plugin) => {\n    let store = createZustandStore(plugin.key)(plugin.options, {\n      immer: {\n        enableMapSet: true,\n      },\n    });\n\n    // Apply option extensions\n    if (\n      (plugin as any).__optionExtensions &&\n      (plugin as any).__optionExtensions.length > 0\n    ) {\n      (plugin as any).__optionExtensions.forEach((extension: any) => {\n        const extendedOptions = extension(getEditorPlugin(editor, plugin));\n\n        store = store.extendSelectors(() => extendedOptions);\n      });\n    }\n\n    plugin.optionsStore = store;\n  });\n};\n\nconst resolvePluginApis = (editor: SlateEditor) => {\n  const shortcutsByPriority: any[] = [];\n\n  editor.pluginList.forEach((plugin: any) => {\n    // Merge APIs\n    Object.entries(plugin.api).forEach(([apiKey, apiFunction]) => {\n      (editor.api as any)[apiKey] = apiFunction;\n    });\n\n    // Apply API and transform extensions\n    if (plugin.__apiExtensions && plugin.__apiExtensions.length > 0) {\n      plugin.__apiExtensions.forEach(\n        ({ extension, isPluginSpecific, isTransform }: any) => {\n          const newExtensions = extension(\n            getEditorPlugin(editor, plugin) as any\n          );\n\n          if (isTransform) {\n            // Handle transforms\n            if (isPluginSpecific) {\n              // Plugin-specific transform\n              if (!(editor.transforms as any)[plugin.key]) {\n                (editor.transforms as any)[plugin.key] = {};\n              }\n              if (!(plugin.transforms as any)[plugin.key]) {\n                (plugin.transforms as any)[plugin.key] = {};\n              }\n\n              merge((editor.transforms as any)[plugin.key], newExtensions);\n              merge((plugin.transforms as any)[plugin.key], newExtensions);\n            } else {\n              // Editor-wide transform\n              merge(editor.transforms, newExtensions);\n              merge(plugin.transforms, newExtensions);\n            }\n          } else {\n            // Handle APIs\n            if (isPluginSpecific) {\n              // Plugin-specific API\n              if (!(editor.api as any)[plugin.key]) {\n                (editor.api as any)[plugin.key] = {};\n              }\n              if (!(plugin.api as any)[plugin.key]) {\n                (plugin.api as any)[plugin.key] = {};\n              }\n\n              merge((editor.api as any)[plugin.key], newExtensions);\n              merge((plugin.api as any)[plugin.key], newExtensions);\n            } else {\n              // Editor-wide API\n              merge(editor.api, newExtensions);\n              merge(plugin.api, newExtensions);\n            }\n          }\n        }\n      );\n      delete plugin.__apiExtensions;\n    }\n\n    // Merge shortcuts\n    Object.entries(plugin.shortcuts).forEach(([key, hotkey]) => {\n      if (hotkey === null) {\n        // Remove any existing hotkey with this key\n        const index = shortcutsByPriority.findIndex((item) => item.key === key);\n\n        if (index !== -1) {\n          shortcutsByPriority.splice(index, 1);\n        }\n      } else {\n        const priority = (hotkey as any).priority ?? plugin.priority;\n        const existingIndex = shortcutsByPriority.findIndex(\n          (item) => item.key === key\n        );\n\n        if (\n          existingIndex === -1 ||\n          priority >= shortcutsByPriority[existingIndex].priority\n        ) {\n          if (existingIndex !== -1) {\n            shortcutsByPriority.splice(existingIndex, 1);\n          }\n\n          shortcutsByPriority.push({ key, hotkey, priority });\n        }\n      }\n    });\n  });\n\n  // Sort shortcuts by priority (descending)\n  shortcutsByPriority.sort((a, b) => b.hotkey.priority - a.hotkey.priority);\n\n  // After processing all plugins, set the final shortcuts on the editor\n  editor.shortcuts = Object.fromEntries(\n    shortcutsByPriority.map(({ key, hotkey }) => {\n      const { priority, ...hotkeyWithoutPriority } = hotkey;\n\n      return [key, hotkeyWithoutPriority];\n    })\n  );\n};\n\nconst flattenAndResolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): Map<string, SlatePlugin> => {\n  const pluginMap = new Map<string, SlatePlugin>();\n\n  const processPlugin = (plugin: SlatePlugin) => {\n    const resolvedPlugin = resolvePlugin(editor, plugin);\n    const existingPlugin = pluginMap.get(resolvedPlugin.key);\n\n    if (existingPlugin) {\n      pluginMap.set(\n        resolvedPlugin.key,\n        mergePlugins(existingPlugin, resolvedPlugin)\n      );\n    } else {\n      pluginMap.set(resolvedPlugin.key, resolvedPlugin);\n    }\n    if (resolvedPlugin.plugins && resolvedPlugin.plugins.length > 0) {\n      resolvedPlugin.plugins.forEach(processPlugin);\n    }\n  };\n\n  plugins.forEach(processPlugin);\n\n  return pluginMap;\n};\n\nexport const resolveAndSortPlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): SlatePlugins => {\n  // Step 1: Resolve, flatten, and merge all plugins\n  const pluginMap = flattenAndResolvePlugins(editor, plugins);\n\n  // Step 2: Filter out disabled plugins\n  const enabledPlugins = Array.from(pluginMap.values()).filter(\n    (plugin) => plugin.enabled !== false\n  );\n\n  // Step 3: Sort plugins by priority\n  enabledPlugins.sort((a, b) => b.priority - a.priority);\n\n  // Step 4: Reorder based on dependencies\n  const orderedPlugins: SlatePlugins = [];\n  const visited = new Set<string>();\n\n  const visit = (plugin: SlatePlugin) => {\n    if (visited.has(plugin.key)) return;\n\n    visited.add(plugin.key);\n\n    plugin.dependencies?.forEach((depKey) => {\n      const depPlugin = pluginMap.get(depKey);\n\n      if (depPlugin) {\n        visit(depPlugin);\n      } else {\n        editor.api.debug.warn(\n          `Plugin \"${plugin.key}\" depends on missing plugin \"${depKey}\"`,\n          'PLUGIN_DEPENDENCY_MISSING'\n        );\n      }\n    });\n\n    orderedPlugins.push(plugin);\n  };\n\n  enabledPlugins.forEach(visit);\n\n  return orderedPlugins;\n};\n\nexport const applyPluginsToEditor = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n) => {\n  editor.pluginList = plugins;\n  editor.plugins = Object.fromEntries(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n};\n\nexport const resolvePluginOverrides = (editor: SlateEditor) => {\n  const applyOverrides = (plugins: SlatePlugin[]): SlatePlugin[] => {\n    let overriddenPlugins = [...plugins];\n\n    const enabledOverrides: Record<string, boolean> = {};\n    const componentOverrides: Record<\n      string,\n      { component: any; priority: number }\n    > = {};\n    const pluginOverrides: Record<string, Partial<SlatePlugin>> = {};\n\n    // Collect all overrides\n    for (const plugin of plugins) {\n      if (plugin.override.enabled) {\n        Object.assign(enabledOverrides, plugin.override.enabled);\n      }\n      // TODO react\n      if ((plugin.override as any).components) {\n        Object.entries((plugin.override as any).components).forEach(\n          ([key, component]) => {\n            if (\n              !componentOverrides[key] ||\n              plugin.priority > componentOverrides[key].priority\n            ) {\n              componentOverrides[key] = {\n                component,\n                priority: plugin.priority,\n              };\n            }\n          }\n        );\n      }\n      if (plugin.override.plugins) {\n        Object.entries(plugin.override.plugins).forEach(([key, value]) => {\n          pluginOverrides[key] = mergePlugins(pluginOverrides[key], value);\n\n          if (value.enabled !== undefined) {\n            enabledOverrides[key] = value.enabled;\n          }\n        });\n      }\n    }\n\n    // Apply overrides\n    overriddenPlugins = overriddenPlugins.map((p) => {\n      let updatedPlugin = { ...p };\n\n      // Apply plugin overrides\n      if (pluginOverrides[p.key]) {\n        updatedPlugin = mergePlugins(updatedPlugin, pluginOverrides[p.key]);\n      }\n      // Apply component overrides\n      // TODO react\n      if (\n        componentOverrides[p.key] &&\n        ((!(p as any).render.node && !(p as any).node.component) ||\n          componentOverrides[p.key].priority > p.priority)\n      ) {\n        (updatedPlugin as any).render.node =\n          componentOverrides[p.key].component;\n        (updatedPlugin as any).node.component =\n          componentOverrides[p.key].component;\n      }\n\n      // Apply enabled overrides\n      const enabled = enabledOverrides[p.key] ?? updatedPlugin.enabled;\n\n      if (isDefined(enabled)) {\n        updatedPlugin.enabled = enabled;\n      }\n\n      return updatedPlugin;\n    });\n\n    return overriddenPlugins\n      .filter((p) => p.enabled !== false)\n      .map((plugin) => ({\n        ...plugin,\n        plugins: applyOverrides(plugin.plugins || []),\n      }));\n  };\n\n  editor.pluginList = applyOverrides(editor.pluginList as any);\n  editor.plugins = Object.fromEntries(\n    editor.pluginList.map((plugin) => [plugin.key, plugin])\n  );\n};\n","import type { MaybeReturnType } from '../../types/misc/types';\n\nimport { isFunction } from './isFunction';\n\n/**\n * Optionally calls `value` as a function. Otherwise it is returned directly.\n *\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    return value(...props);\n  }\n\n  return value as MaybeReturnType<T>;\n}\n","/** Get slate class name: slate-<type> */\nexport const getSlateClass = (type: string) => `slate-${type}`;\n","function getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nfunction isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false;\n  }\n\n  return (\n    value.constructor === Object &&\n    Object.getPrototypeOf(value) === Object.prototype\n  );\n}\n\nexport function mergeDeep(\n  target: Record<string, any>,\n  source: Record<string, any>\n): Record<string, any> {\n  const output = { ...target };\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      output[key] =\n        isPlainObject(source[key]) && isPlainObject(target[key])\n          ? mergeDeep(target[key], source[key])\n          : source[key];\n    });\n  }\n\n  return output;\n}\n","import type { SlateEditor } from '../editor';\nimport type {\n  AnyPluginConfig,\n  PluginConfig,\n  WithRequiredKey,\n} from './BasePlugin';\nimport type { AnySlatePlugin, SlatePlugin } from './SlatePlugin';\n\nimport { resolvePlugin } from '../utils';\nimport { createSlatePlugin } from './createSlatePlugin';\n\n/** Get editor plugin by key or plugin object. */\nexport function getSlatePlugin<C extends AnyPluginConfig = PluginConfig>(\n  editor: SlateEditor,\n  p: WithRequiredKey<C>\n): C extends { node: any } ? C : SlatePlugin<C> {\n  let plugin = p as any;\n\n  const editorPlugin = editor.plugins[p.key] as any;\n\n  if (!editorPlugin) {\n    // When passing only { key }\n    if (!plugin.node) {\n      plugin = createSlatePlugin(plugin);\n    }\n\n    // Resolve is need when passing an external plugin with extensions (e.g. in withLink)\n    return plugin.__resolved ? plugin : resolvePlugin(editor, plugin);\n  }\n\n  return editorPlugin;\n}\n\n/** Get editor plugin type by key or plugin object. */\nexport function getPluginType(\n  editor: SlateEditor,\n  plugin: WithRequiredKey\n): string {\n  const p = editor.getPlugin<AnySlatePlugin>(plugin);\n\n  return p.node.type ?? p.key ?? '';\n}\n\n/** Get editor plugin types by key. */\nexport const getPluginTypes = (\n  editor: SlateEditor,\n  plugins: WithRequiredKey[]\n) => plugins.map((plugin) => editor.getType(plugin));\n","export { nanoid } from 'nanoid';\n","export type {\n  StateActions as ZustandStateActions,\n  StoreApi as ZustandStoreApi,\n} from 'zustand-x';\n\nexport { createZustandStore } from 'zustand-x';\n"],"mappings":"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","names":["config","result","plugin","isElement","isText","replaceNodeChildren","replaceNodeChildren","bindFirst","jsx","isElement","_a","_b","jsx","jsx","jsx","bindFirst","document","isText","isElement","isElement","isDefined","isElement","isDefined","withoutNormalizing","withoutNormalizing","_a","_b","_a","merge","merge","isDefined","merge","merge","isDefined","_a","_b","value","createZustandStore"]}